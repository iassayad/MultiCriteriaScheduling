\documentclass[11pt,twoside]{report}
\usepackage{html}
\usepackage{fullpage}

\begin{document}
\title{Syndex v6 - User Manual}
\author{Julien Forget, Christophe Lavarenne, Yves Sorel}
\date{\today}
\maketitle
\tableofcontents

\chapter{Overview}
A SynDEx application is made of algorithm graphs (definitions of
operations that the application may execute) and architecture graphs
(definitions of multicomponents: set of interconnected processors and
specific integrated circuits). Performing an adequation means to
execute heuristics seeking for an optimized implementation of a given
algorithm onto a given architecture.\\\\
"Adequation" means an efficient mapping. An implementation consists in
distributing (allocate parts of algorithm onto components) and
scheduling (give a total order for the operations
distributed onto a component) the algorithm onto the architecture.\\\\
SynDEx runs under Linux, Solaris and Windows platforms.\\\\
SynDEx is written in \htmladdnormallink{{\it Objective
    Caml}}{http://caml.inria.fr/index-eng.html}. The GUI is written in
\htmladdnormallink{{\it Tcl/Tk}}{http://www.scriptics.com/} with the
OCaml library \htmladdnormallink{{\it
    CamlTk}}{http://pauillac.inria.fr/camltk/}.

\chapter{Getting started}
To create an application workspace, run the syndex-6.?.? executable,
located at the root of your installation directory. This will open the
principal window of SynDEx. Be sure to read the README if you have
some troubleshooting.\\\\
To open an existing application and thus fill the workspace, choose in
the principal window the OPEN option from the menu FILE, and then
choose an "applicationName.sdx" file. This will open the (main)
algorithm window and the (main) architecture window if they have been
defined. "(main)" means that it is on these two graphs that the
adequation will be
applied. Opening another application replaces the present application by the new one in the workspace.\\\\
To close an application, choose in this principal window the CLOSE
option from the menu FILE. This will close all the windows and leave the workspace empty.\\\\
To save an application with its current name, choose in the principal window the SAVE option from the menu FILE.\\\\
To save an application with a new name, choose in the principal window
the SAVE AS option from the menu FILE. This will open a standard
browsing window in order to choose the new name.\\\\
Notice that you can save the result of the last adequation you
computed with your application by enabling the option SAVE ADEQUATION
RESULT in the OPTIONS menu. Next time you will load the application,
you will not have to recompute the adequation.\\\\
To quit the application, choose in the principal window the QUIT
option from the menu FILE.

\chapter{Libraries}
To create a new application you may want to use predefined algorithm
definitions, operators or media. To include a library in an
application in order to make references to the objects it contains,
choose the option INCLUDE LIBRARY from the menu FILE of the principal
window. You can un-include an included library the same way, provided
there are no references in your application on definitions of this library.\\\\
To create libraries of algorithm definitions or operators or media,
you must create a file .sdx containing the definitions you need. These
libraries must be located in a directory named "libs", by default
located at the root of your install directory, or which
location may be specified with the "-libs" option of the SynDEx command line (in the script used to launch SynDEx).\\\\

\chapter{Using the interface}
\section{Contextual menus}
To open a contextual menu on a window, point the cursor at the window
background, then click the right button of the mouse and choose the
appropriate option. This allows you to perform most of the actions
described in the EDIT menus of the corresponding window. These menus
mainly include edition commands (cut, paste, copy, etc) and a useful
INFO BUBBLES option which displays additionnal information when you
point to a vertice of your graph (either algorithm, architecture or
adequation schedule view).\\\\
To open a contextual menu on a vertex, an edge or a port, point the
cursor of the mouse on the object, then click the right button of the
mouse and choose the appropriate option. This allows you to perform
most of the actions described in the EDIT menus.


\section{Selection}
Selection may be applied to vertices or edges of both algorithm or architecture graphs.\\\\
To select one vertex, point the cursor at this vertex which borders
will appear red highlighted, click the left button of the mouse. When
a vertex is selected small black squares appear at each corner of the
vertex. To select incrementally vertices, click them while pressing
SHIFT key. Selecting an already selected vertex will un-select it. You
may select a group of vertices by pressing the right button of the
mouse while dragging it, in order to draw a square when the button is
released. Vertices inside or intersecting the square are selected.\\\\
To move a selection, point the cursor at a vertex of this selection,
click the left button of the mouse and drag until the next
position. When the button is released the selection remains at this
position.\\\\
To cancel a selection click outside this selection.\\\\
To cut, copy, paste, a selection, as usual choose the corresponding
options in the menu EDIT of the corresponding window, or respectively
use the classical short-cut key: Ctrl-X, Ctrl-C, Ctrl-V.

\section{Zoom}
Zoom may be applied to algorithm, architecture or timing windows by
moving the zoom cursor on the border of the windows.

\section{Contextual informations}
When the cursor points at an object of an algorithm, an architecture
or a timing window, information is displayed in the principal window.\\\\
By default information is not kept when you switch between objects.
The new information overwrites the older one. You can change this
behaviour and keep all the information by enabling the option KEEP
INFORMATION IN MAIN WINDOW (shortcut Ctrl-K) in the OPTIONS menu. This
is for instance useful when the information displayed does not fit in
the window, which requires you to scroll the main window.

\section{Retrieving a vertex in a complex graph}
Looking for a vertex, from which you now the name, in a complex graph
can become rather tedious. In the algorithm, architecture and
adequation result windows, you can use the commands FIND
REFERENCE/PORT/OPERATION/OPERATOR/MEDIUM, to locate a vertex of your
graph by its name. This will open a window listing all the vertices of
your graph. Double-clicking on one of them will select it.

\section{Graph elements becoming inactive}
Sometimes, you will notice that some elements of a graph, that is to
say vertices or edges, become ``inactive''. For instance, you can't
move a vertice or select a port anymore. In such a case, use the
refresh command (shortcut Ctrl-R) which will bring the graph behaviour
back to normal.

\chapter{Algorithm}
In AAA methodology, an algorithm is specified as a directed acyclic
graph (DAG) infinitely repeated. Directed means that for each edge
representing a relation between vertices, the vertices n-uple is
ordered, i.e. its first element is the source
vertex the other one(s) is (are) the destination vertex(ices).\\\\
Still in AAA, vertices are operations; operation stands for a sequence
of instructions which starts after all its input data is available and
produces output data at the end of the sequence.  In SynDEx, there is
an additionnal notion of reference. To each reference corresponds the
definition of an algorithm (we will say ``definition'' instead of
``algorithm definition'' for the rest of this chapter). The same
definition may correspond to several references to this definition.
An algorithm definition is a DAG similar to those in AAA, except that
vertices are references or ports. A reference in a definition may
correspond to a definition which contains several references and so
on. Ports are used only for propagating back and
forth edges along the hierarchy.\\\\
In SynDEx, algorithms can be defined through hierarchy. A definition
is said hierarchical when it defines (explicitly or implicitly) an
algorithm which contains at least one dependence (and possibly
references), otherwise it is said
atomic.\\\\
A definition is said explicitly hierarchical when the algorithm
specified by the user contains at least one edge (and possibly
references). This includes conditioning, repetitions of hierarchical
definitions and, more generally, definitions defined
through several levels of hierarchy.\\\\
A definition is said implicitly hierarchical when the algorithm
specified by the user doesn't contain any dependence and yet will be
transformed by SynDEx, for the adequation, into a graph which contains
dependences. This happens only with
repetitions of atomic definitions.\\\\
In a definition window, references to a definition explicitly
hierarchical are displayed with a double-border, references to
conditioned definitions have their conditioning port displayed in
yellow and the repetition factor of a reference is displayed next to
to the references name.\\\\
There are five types of definitions: constant (input vertex of the
DAG, null execution time) and sensor (input vertex of the DAG
producing data from a physical sensor) which both have no input ports,
actuator (output vertex of the DAG consuming data for a physical
sensor) which has no output port, function (reads data on input ports,
executes instructions without any side-effect, writes data on output
ports), and delay (memorizes data during one or several infinite
repetition of the DAG, for use in next repetitions). Only a function
may be defined through explicit hierarchy.\\\\
WARNING: A hierarchical definition does not have to wait for all its
input data to be available before starting some computations. Indeed,
parts of the algorithm graph of a hierarchical algorithm definition
may only require parts of the input data of the definition and
therefore can start as soon as this part is available (and not all the
data). In the same way, some data may be produced before the end of
the complete sequence of
computations.\\\\
%There are four types of edges: strong data communication and execution
%precedence, weak data communication and execution precedence, data
%communication only, or execution precedence only. The two first types of
%edges impose that the reference which produces the data is executed
%before the reference which consumes the data,
%(the execution order of the operation depends on the way they access to data)
%whereas in the case of the third type of edge the reference which produces the
%data may be executed before or after the reference which consumes the data
%(blackboard). Strong data communication means that during the first
%repetition and only during the first repetition of the DAG, the reference which
%produces the data is executed before the reference which consumes the data,
%whereas weak data communication means that during the first repetition of
%the DAG the reference which produces the data is executed after the reference
%which consumes the data, implying that this reference consumes a data
%specifically initialized. The fourth type of edge only imposes an execution
%order between references, no data is consumed or produced.\\\\
There are two types of edges: strong data communication and execution
precedence, or execution precedence only. The first type imposes that
the reference, at the source of the dependence, produces data and is
executed before the reference, at the destination of the dependence,
which consumes the data. The second type only imposes an execution
order between references, no data is produced or consumed.\\\\
In a definition window, to open the definition corresponding to a
reference in order to inspect and possibly modify its content, point
the cursor at this reference which borders will highlight in red, then
double click the left button of the mouse. This will display the graph
of the definition in a new window.\\\\To label an algorithm window
with "(main)", choose MAIN DEFINITION in the EDIT menu. Notice that
the algorithm (main) must be at the root level of a hierarchy; it
can't contain ports.\\\\To open the algorithm (main) definition,
choose the option EDIT MAIN DEFINITION in the menu ALGORITHM of the
principal window.

\section{To create an algorithm definition}
To create a new local definition, choose the option NEW LOCAL
DEFINITION / FUNCTION-CONSTANT-SENSOR-ACTUATOR-DELAY in the menu
ALGORITHM of the principal window, this will open a window for text
edition in order to input its name and possibly a list of parameter
names, and will create a new
definition window labeled "name".\\\\
The paramater are used to create more generic definitions (for example
for the ports of type array, to parametrize the dimension of the
array) and are separated by semi-colons.\\\\
Delay definitions must have a single input/output port and at least
one parameter. This parameter, called the delay range (N) is the number of
graph repetitions during which values will be memorized. It must be
the last parameter of this definition. Be aware
that the delay must have initial values for the N first infinite
repetitions of the graph either by using a parameter for these initial
values or by initialising it in the macro-code.\\\\
Now you may construct a graph with references to constants, sensors,
actuators, delays and function. If this definition is intended to be
referenced in an explicit hierarchy, i.e. this reference will belong
to a certain level of hierarchy (possibly a leaf), you must use input
and output ports. If this definition is intended to be referenced at
the root level of the hierarchy, input ports are replaced by sensors
and output
ports are replaced by actuators.\\\\
To create an input or an output port, choose the option CREATE PORT in
the menu EDIT of the definition window, this will open a window for
text edition in order to input for each port its name, direction
(input, output, or input/output), and type that you can arbitrarily
define: for example integer or int, float, bool, ... or array of
integer, float, bool, ... WARNING: each type must be associated to a
duration (cf. chapter \ref {characteristics}). Array types are
specified with the classical square brackets delimiter. You can use a
parameter to specify the size of an array port. You can either
directly use the name of the parameter between the square brackets if
the parameter is an integer (e.g. ``?~float[N]~i'') or put the name of
the parameter between pipes for the length of the parameter if the
parameter is a list (e.g. ``?~float[|L|]~i''). Parameter
values won't be evaluated by SynDEx until you choose a main algorithm.\\\\
If you plan to generate code, it is necessary to specify an order for
the ports, consistent with the declaration of the corresponding
executable function. To specify the ports order, choose the option
PORTS ORDER of the contextual menu.\\\\ To create a reference to a
definition, choose the option CREATE REFERENCE in the menu EDIT of the
definition window, this will open a window for text edition in order
to input the reference name and possibly a list of arguments values
and a repetition factor. Arguments can be lists, separated by
semi-colons.  Values in lists are separated by comas and the whole
list is delimited with round brackets (e.g.  ``delay
<\{5,6,4,3\};2>''). For the repetition factor, see section ``To modify
an algorithm definition or a reference''.\\\\
To create dependences between references or ports, point the cursor at
an output of the source reference, or at an input port, and click the
middle button of the mouse (or CTRL+click the left button of the
mouse) and drag to an input of a destination reference, or at an
output port. When the button is released the edge will be drawn.
Notice that you can point on the name of the port and not only on the
small black square.\\\\ Connecting two vertices will create a
dependence which type is the default type. To set the default type of
the dependences choose DEFAULT EDGE TYPE in the menu EDIT of the
definition window.\\\\ To change an edge type, point the cursor at
this edge which will highlight, then click the right button of the
mouse and choose the new type.

\section{To condition an algorithm definition}
To condition a definition, choose the command CREATE CONDITION in the
EDIT menu of the definition window, this will open a window for text
edition in order to input the name and the values the conditioning may
take. The name of the conditioning must be the name of an existing
input port of type integer. The conditioning is a list, where each
element, separated by spaces, is the name of the conditioning port and
the value it may take, separated by ``='' (e.g. ``cond=1 cond=2
cond=3''). This specific port must be unique for a definition. Once
you have created a conditioning, the
conditioning port is colored yellow.\\\\
Each value the conditioning may take, will have a corresponding button
at the top of the definition window. After selecting one value by
clicking on the corresponding button, you will have to construct a
graph. This graph describes the algorithm executed when the
conditioning takes this value. During the execution, only the graph
corresponding to the value that the conditioning port will have, will
be executed.

\section{To repeat an algorithm definition}
\subsection{Implicit repetition specification}
In most cases, to repeat an algorithm definition, you should use the
implicit repetition specification. Create a reference
to a definition such that the number of elements of the type of each
input is an exact divisor (submultiple) of the number of elements of
the type of the corresponding output it is connected to, and
similarly, the number of elements of the type of each ouput is a
sub-multiple of the number of elements of the type of the
corresponding input it is connected to.  The ratio between the number
of elements of each input (resp.  output) and the number of elements
of the output (resp. input) it is connected to, gives the number of
repetitions; we call this situation a Fork-Join. WARNING: all the
ratios of the repeated definition must be the same, otherwise it is
not consistent. However, some inputs may have ratio one, whereas the
common ratio is greater than one, in this case the input is replicated
as much time as the common ratio; we call this situation Diffuse.
Similarly, some outputs may have ratio one, whereas the common ratio
is greater than one, in this case the output of the repetition {\it i}
becomes the input of the repetition {\it i+1}, and the definition must
have a corresponding input/output port, which SynDEx will use to
connect the successive repetitions; we call this situation Iterate.
The output of the last repetition is the output of the
repeated definition. Input/output port must be initialized.\\\\
Hence, the number of repetition applied to the definition is implicit,
it is calculated by SynDEx which will automatically repeat the
algorithm definition and create the corresponding expanded graph. The
repetition factor is displayed next to the name of the reference. It
is the expanded graph which will be taken into account during the
adequation and the code generation.  The expansion will introduce new
vertices called {\it explode} and {\it implode}. The {\it explode}
vertex extracts for each repetition of a definition each element of
the data it receives, whereas the {\it implode} vertex builds the data
it sends by concatenating each separated element produced by each
repetition of the definition.\\\\
Suppose that you want to specify the
multiplication of a vector {\it V} by a scalar {\it S} giving a vector
{\it W} as result. You can specify it using the multiplication between
two scalars instead of defining a new multiplication between a vector
and a scalar. By the way, this allows you to specify more parallelism.
For example if the dimension of the vector is three, you may specify
the repetition by three multiplications between two reals giving a
real as a result, by referencing this definition and connecting one of
the two inputs to an output which is a vector of three real ({\it V}),
and the other input to an output of one real ({\it S}), and connecting
its output to an input which is a vector of three reals ({\it W}). The
common ratio is three, and one input has a ratio one that is to say
the real is replicated three times in order to be multiplicated by one
of the three elements of the vector.

\subsection{Explicit repetition specification}
In some cases, you may want to specify a repetition of a definition
but have no difference between port sizes. You must then use explicit
repetition specification instead of the implicit specification. Create
a reference to the definition and specify a repetition factor in the
reference creation window. The repetition factor is specified after
the reference name and the optional arguments list, and is also
optional. The repetition is specified as an integer between square
brackets. For instance, ``minus [3]'' specifies three repetition of definition.\\\\
It is important to notice that with explicit repetition you can only
express the Diffuse and Iterate situation, as all port ratios equal
one.

\subsection{Explicit versus implicit}
Implicit repetition is prioritary to explicit repetition for
consistancy purposes. Therefore, you can't specify an explicit
repetition on a definition which is already implicitly repeated. The
port ratios would not be consistant anymore.\\\\
Furthermore, if you perform some actions on your algorithm graph which cause
the port ratios of a definition explicitly repeated to change, the
definition becomes implicitly repeated and the explicit repetition
factor is lost.


\section{To modify an algorithm definition or a reference}
To open a definition, choose the
option EDIT DEFINITION in the menu ALGORITHM of the principal window,
you may also point at a reference in a definition window and double
click when highlighted. In both cases this will open a definition window.\\\\
To modify a local definition, use one option of the EDIT menu in order
to create input and output ports, references to constants, sensors, actuators, memories and operations.\\\\
To modify the definitions of a library, open the file of this
library which is in the directory "libs", by using the option OPEN of
the menu FILE. It is not possible to modify the definitions of a
library when you are working in an application which includes this
library. Be aware that changes in a definition are considered for all
references on it. In particular, changing a definition in a library
may have consequences on several applications using this library.\\\\
To modify a reference, use the contextual menu related
to the reference. To obtain this contextual menu point at a reference
which borders will highlight in red, then click the right button of the mouse.

\section{To delete an algorithm definition}
To delete a local definition choose the option DELETE LOCAL DEFINITION in the menu ALGORITHM of the principal window.

\chapter{Architecture}
An architecture is specified as a non directed graph where vertices are of
two types: operator or medium, and each edge is a connection between an
operator and a medium.\\\\ To label an architecture window with "(main)", choose MAIN
ARCHITECTURE in the EDIT menu.\\\\To open the architecture (main), choose the
option EDIT MAIN ARCHITECTURE in the menu ARCHITECTURE of the principal window.

\section{Operator}
\subsection{To create an operator definition}
To create a new operator definition, choose the option NEW LOCAL
OPERATOR DEFINITION in the menu ARCHITECTURE of the principal window,
this will open a window for text edition in order to input a name to
this new operator definition. This will open a definition window in
which you may modify the gates list and the operation durations list
of the operator.\\\\
In the gates list window, you specify the gate type and the gate name
separated by a space (e.g. ``TCP x''); one gate per line.\\\\
In the durations list window, you specify the definition name and its
duration, which is an integer, separated by a ``='' (e.g.
``add~=~1''); one duration per line. Notice that when the duration for
a definition ``algo'' has already been specified in an included
library ``lib'' the duration will appear in the duration window as
``lib/algo~=~...''. You should not modify this duration directly in
your application (it will not be saved). As it belongs to the library,
modify the library itself instead (but the modification will be taken
into account for all the applications including it).

\subsection{To modify an operator definition}
To modify an existing local or global library operator definition,
choose the option EDIT OPERATOR DEFINITION in the menu ARCHITECTURE of
the principal window, this will open a definition window.

\subsection{To delete an operator definition}
To delete a local operator definition choose the option DELETE LOCAL OPERATOR in the menu ARCHITECTURE of the principal window.

\section{Medium}
\subsection{To create a medium definition}
To create a new medium definition, choose the option NEW LOCAL MEDIUM
DEFINITION in the menu ARCHITECTURE of the principal window, this will
open a window for text edition in order to input a name to this new
medium definition. This will open a definition window in which you may
modify the type of the medium (SAM Point to Point, SAM Multipoint,
RAM) and the communication durations list of the medium.\\\\
In the durations list window, you specify the type name and its
duration, which is an integer, separated by a ``='' (e.g.
``int~=~1''); one duration per line. Each line specifies the duration
required to transfer one element of this type (e.g. an array of four
integers will take 4*1). The special type ``prec\_synchro''is used for
dependences of type Precedence. Notice that if the duration for one type
``type'' has already been specified in an included library ``lib'' the
duration will appear in the duration window as ``lib/type~=~...''. You
can still redefine the duration for your application by adding a line
``type=...''. This addition will not modify the library itself (no
repercusion on other applications including this library).


\subsection{To modify a medium definition}
To modify an existing local or global library medium definition, choose
the option EDIT MEDIUM DEFINITION in the menu ARCHITECTURE of the
principal window, this will open a definition window.\\\\

\subsection{To delete a medium definition}
To delete a local medium definition choose the option DELETE LOCAL MEDIUM in the menu ARCHITECTURE of the principal window.

\section{Architecture}
\subsection{To create an architecture definition}
To create a new local architecture choose the option NEW LOCAL ARCHITECTURE in the menu ARCHITECTURE of the principal window, this will open a window for text edition in order to input a name to this new architecture, and create a new window labeled "architectureName". Now you may construct a graph with references to already defined operators and media all together connected. A reference to an operator or to a medium may belong locally to an application or belong to a library global to all the applications.\\\\
To connect an operator and a medium, or a medium to an operator, point the cursor at a gate of the operator (respectively the medium) and click the middle button of the mouse (or CTRL+click the left button of the mouse) and drag to the gate of the medium (a gate of the operator). When the button is released the edge will be drawn.\\\\
WARNING : it is not allowed to connect together two media, or two operators.

\subsection{To modify an architecture definition}
To modify an existing local or global library architecture, choose the option EDIT ARCHITECTURE in the menu ARCHITECTURE of the principal window, this will open a window definition.

\subsection{To delete an architecture definition}
To delete a local architecture definition choose the option DELETE LOCAL ARCHITECTURE in the menu ARCHITECTURE of the principal window.

\chapter{Characteristics}
\label{characteristics}
The heuristics performed by the adequation use the characteristics of
each algorithm definition and each relation (edge) between algorithm
definition, relatively to the operators and the media it may be
distributed to. Presently we are mainly interested in real-time
performances then the vertices and the edges of the algorithm graph
must be characterized in terms of
duration relatively to the vertex types of the architecture graph.\\\\
Communication characterizations are explained in section ``Medium''.
Notice that the command MAIN DEFINITION PORT TYPES LIST in the
ALGORITHM menu gives you a list of all port types used in your main
definition algorithm and its subhierarchy, which may
simplify the specification of communication characterizations.\\\\
To perform definitions characterization, you have two possibilities: -
choose the option DURATIONS in the EDIT menu of an algorithm window
(this will open a dialog window in order to input the
characteristics), - edit the definition of the operator and use the
button MODIFY DURATIONS (this will open a dialog window in order to
input the
characteristics).\\\\
WARNING : You must characterize all vertices of the transformed graph
(see below).

\chapter{Constraints}
Some vertices of the algorithm graph may be constrained to be executed
on a specific operator, in this case the heuristics will not have the
choice in distributing them. These constraints are specified through
"Software Components". A software component groups operations, all
operations of a software component will be distributed on the same
operator.\\\\
To create a new software component, choose CREATE SOFTWARE COMPONENT
in the menu EDIT. To attach a reference to a software component, use
the option ATTACH REFERENCE TO SOFTWARE COMPONENT of the contextual
menu. If this reference references a hierarchical definition, the
software component will be herited by all the references of this
hierarchy (except if some references of this hierarchy are themselves
attached to another software component). In particular, if you use
this command on a reference to a conditioned definition (resp.
repeated) the software component will be herited by the CondI/CondO
(resp. Explode, Implode) created by SynDEx when flattening the
algorithm graph. You may also attach a specific software component to
CondI/CondO/Explode/Implode by using the options ATTACH
CONDI/CONDO/EXPLODE/IMPLODE TO SOFTWARE COMPONENT. The option ATTACH
ALL TO SOFTWARE COMPONENT attaches the same software component to all
these operations. Be aware that this last command is more prioritary
than the others. Therefore, if you specify a software component to ALL
and a different to only CONDI, the software component specified
for CONDI will be ignored.\\\\
To constraint the references attached to a given software component to
be distributed on a specific operator, choose CONSTRAINTS in the menu
of the principal window. Then you may impose ABSOLUTE constraints by
choosing the corresponding option. This will open a dialog window in
order to input the
constraints.\\\\
To create an absolute constraint in the constraints window, click on
an operator in the left list, then click on an operator in the middle
and finally click on the CREATE button. This will add the new
constraint in the right list.\\\\
To delete an absolute constraint, click on a constraint in the right
list, then click on the REMOVE button or directly double-click on the
constraint. Click on the OK button to confirm your new constraint
list, otherwise click on the CANCEL button.

\chapter{Adequation}
You may have constructed several local algorithm and/or architecture
definitions, but only one of them may be labeled "(main)" becoming the
algorithm (main) which will be mapped onto the architecture (main),
when the adequation is performed.\\\\
To label an algorithm window or an architecture window with "(main)",
choose MAIN DEFINITION (for the algorithm) or MAIN ARCHITECTURE (for
an architecture) in the EDIT menu.\\\\
To run the adequation, i.e. the optimization heuristics provided by
SynDEx, choose between NO FLATTEN or FLATTEN. In both cases, the main
algorithm graph is transformed by SynDEx to obtain a graph with a
unique level of hierarchy, where each vertex is an operation in the
sense of AAA (which is the same as an atomic definition in SynDEx).
This transformation consists in replacing references, by corresponding
definitions, and replacing paths of dependences connected along the
hierarchy through ports, by direct dependences between corresponding
ports of the transformed operations. The difference between NO FLATTEN
and FLATTEN lies in the references resolution.\\\\
With NO FLATTEN, explicit hierarchy is ignored. In the graph of the
main definition all references are directly replaced by operations
containing the same ports as their definition. References or
dependences included in those definitions are ignored. Additionnally,
repetitions are expanded.\\\\
With FLATTEN, references corresponding to explicitly hierarchical
definitions are replaced by the graph of this definition, conditioning
and repetitions are expanded. This process is iterated until all
vertices of the transformed graph become
atomic (no hierarchy remains).\\\\
Notice that SynDEx needs characterization for each vertex of the
transformed graph to perform the adequation. If you chose NO FLATTEN,
do not forget to characterize the definitions corresponding to
references at the highest level of hierarchy in the main algorithm.
With FLATTEN you only need to characterize atomic definitions. You
will also have to characterize additional operations
generated by SynDEx when you use conditioning or repetition.\\\\
Once the adequation has been computed, or loaded from a previously
saved adequation result, the VIEW SCHEDULE command of the ADEQUATION
MENU opens a window showing a view of the shedules and distribution
produced by the adequation. This window gives a diagram of the
real-time simulation of the algorithm executed
on the architecture.\\\\
The adequation result is appended to your sdx file once the adequation
has been performed and you save your application.\\\\
In the timing window you will find one timing, describing a
distribution, for each operator and each medium of the architecture.
Each timing for an operator describes a scheduling of constants (by
default not displayed, option SHOW CONSTANTS in WINDOW/OPTION),
sensors, actuators, memories and operations.  Each timing for a medium
describes a scheduling of inter-operator communications, sending or
receiving data from or to an operator. Each box has a length which is
proportional to the duration of the corresponding operation. When you
have important duration differences between definitions, you can
disable this proportionnal display, each box will have the same length
(option
SCALE in WINDOW/OPTION).\\\\
When the cursor points at a box this one is highlighted (yellow) as
well as the boxes it is in relation of execution precedence, i.e. its
predecessors (red) and successors (green). You may ask for drawing
arrows between boxes which are in relation of execution precedence by
choosing the option ARROWS in the window obtained from the
WINDOW/OPTIONS menu; you may also choose to have the time in
horizontal (horizontal view) or in vertical (vertical view). You may
move a timing line or column in order to rearrange their respective
positions: point the cursor at this line or column, click the left
button of the mouse and drag until the new position.

\chapter{Code generation}
When the Adequation has been performed, code may be generated for the
(main) architecture.  Choose the GENERATE CODE option of the menu
CODE. This will generate for each operator of the architecture the
code in a file "operator.m4". The files generated are located in the
directory of the current SynDEx application. The files generated may
be viewed choosing the option VIEW CODE of the menu CODE.\\\\
WARNING: to generate code, it is mandatory that an operator of the
architecture have been labeled "main" (using the contextual menu).

\section{Overview}
In this section we give a brief summary of files you will require to
generate and compile your executive. Code generation principles will be
detailed in next sections. Files required are :
\begin{itemize}
\item One ``processorName.m4'' file for each processor specified in your main
  architecture, including ``root.m4''. These files are generated during the executive
  generation by SynDEx;
\item ``applicationName.m4m'';
\item ``applicationName.m4x'', which may be empty;
\item ``GNUmakefile'';
\item ``root.m4x''.
\end{itemize}
For the files which are not generated by SynDEx, most of the time you
can simply copy existing ones (for instance from the example directory)
and make modifications explained in the comments of these files.\\\\
Once you gathered all these files, type ``make'' in your shell. This
will compile, download and execute one executive for each
processor.\\\\
You can also clean your directory by typing ``make clean''.

\section{How to Compile an Executive}
Each macro-executive source file must be first translated by the GNU
m4 macroprocessor, into a text file in the language preferred for the
processor (usually assembler for efficiency, sometimes C or another
high-level language for portability). This translation relies on
several files included in the following order:
\begin{itemize}
\item the first macro-call of the macro-executive source:
  "include(syndex.m4x)", includes the file syndex.m4x, which defines
  all the SynDEx generic (processor-independent) macros, which rely on
  low-level specific macros expected to be defined by the following
  included files;
\item the second macro-call of the macro-executive source:
  "processor\_(processorType, processorName, applicationName, version,
  date)" (where "processorType", "processorName", and
  "applicationName" respectively stand for the processor type name,
  the processor name, and the application name, as specified under
  SynDEx), includes:
\begin{itemize}
\item the file processorType.m4x, which defines low-level macros
  specific to the processorType,
\item the file applicationName.m4x, which defines application-specific macros,
\item the file processorName.m4x, if it exists, which defines macros specific to processorName only.
\end{itemize}
\item then, after the memory-allocation macro-calls, each
  communication sequence starts with a "thread\_(mediaType, mediaName,
  processorNames)" macro-call (where "mediaType", "mediaName", and
  "processorNames" repectively stand for the medium type name, the medi
  name, and the list of the names of the processors connected to the
  medium, as specified under SynDEx), which includes the file
  mediaType.m4x, which defines low-level communication macros specific
  to the medium type.
\end{itemize}
These indirected inclusions, through the names specified under SynDEx,
provide a very flexible and powerful mechanism needed to support
efficiently heterogeneous architectures, with heterogeneous languages
and compilation chains.\\\\
Then each macroprocessed text file must be compiled with the adequate
compiler, and linked with the adequate linker against separately
compatibly-compiled application-specific files and/or
processor-specific libraries, for those macros which cannot simply
inline the desired code, but instead must call separately compiled
codes.

\section{How to Load the Compiled Executive}
In an heterogeneous architecture, there are different compilation
chains, with different executable formats, which have to be transfered
through different types of intermediate media and processors, to be
finally loaded by different boot loaders. For these reasons, a
postprocessor is required for each type of operator, in order to
encapsulate this heterogeneity into a common download format. This is
explained in more details in the Downloader Specification (cf. chapter
\ref {downloader_specification}).

\section{How to Automate the Compilation/Load Process}
All processor types require the same compilation sequence, but with different compilation tools:
\begin{itemize}
\item macroprocessing of the macro-executive generated by SynDEx,
\item compilation into processor-specific object code,
\item linking into processor-memory-map-specific executable code,
\item postprocessing into common downloadable format.
\end{itemize}
This compilation sequence may be automatically generated for each processor by macroprocessing the macro-makefile generated by SynDEx, which includes:
\begin{itemize}
\item a very first macro-call: "include(syndex.m4m)" includes the file
  syndex.m4m, which generates a makefile header, and defines the
  macros "architecture\_", "processor\_", "connect\_", and
  "endarchitecture\_" used in the macro-makefile;
\item the second macro-call: "architecture\_(applicationName, version,
  date)" (where "applicationName" stands for the application name, as
  specified under SynDEx), includes the file applicationName.m4m, if
  it exists, which defines application-specific make-macros;
\item for each processor, a macro-call: "processor\_(processorType,
  processorName, connectorsTypeAndName)" (where "processorType",
  "processorName", and "connectorsTypeAndName" respectively stand for
  the processor type name, the processor name, and a list of pairs,
  one for each media-connector of the processor, with the medium type
  name and the media-connector name, as specified under SynDEx),
  includes the file processorType.m4m, which should have for side
  effect to generate the required compilation dependences for this
  processor;
\item for each medium, a macro-call: "connect\_(mediaType, mediaName,
  connectorsOprAndName)" (where "mediaType", "mediaName", and
  "connectorsOprAndName" respectively stand for the medium type name,
  the medium name, and a list of pairs, one for each processor
  connected to the medium, with the processor name and its
  media-connector name, as specified under SynDEx), includes the file
  mediaType.m4m, if it exists, which should have for side effect to
  generate any loader-specific dependences (presently unused).
\end{itemize}
Although this indirect inclusion mechanism is able to generate most of
the core makefile, an application-specific "top" makefile is still
required to specify how to generate the core makefile, and to specify
the compilation and linking dependencies with application-specific
files (include files, separately compiled files and libraries).

\chapter{SynDEx Downloader Specification}
\label{downloader_specification}

\section{Context}
SynDEx allows the efficient programming of parallel, distributed,
heterogeneous architectures, composed of several different types of
processors, and of several different types of communication medium. From
a user specification of an algorithm dataflow graph and of an
architecture resources graph, and from algorithm and architecture
characterized libraries, SynDEx automatically generates an application
specific executive code for each processor, and a makefile to automate
the compilation and linking of each executive, and its downloading into
the program memory of the corresponding processor.\\\\
Separate programming of non-volatile program memories being unpractical,
SynDEx considers that each processor has, for only non-volatile resident
program, a boot-loader (which may be very small and simple, or may rely
on a big and complex operating system) expecting an executive to be
downloaded from a neighbour processor through a communication medium,
except for a single "host" processor, designated by the name "root" in
the specified architecture graph, which boot-loader expects all
executives to be stored altogether in its local non-volatile memory.\\\\
Consequently, SynDEx computes, over the architecture graph, an oriented
coverage tree rooted on the "root" processor, and generates in each
processor executive the code needed to download the compiled executives
through this tree, in a predetermined order which is also used to
generate the makefile.

\section{Boot and Download Process}
This process is the same for all processors, except that the root
processor gets executives from its local non-volatile memory, whereas
all the other processors get executives from their neighbour processor
which is their ascendant towards the root of the download tree. The
processors which have the same ascendant processor are called the
descendants of that processor.\\\\
When powered on, each processor boots by executing its resident
boot-loader, which gets the processor's executive, loads it into the
processor's program memory, and executes it. During its initialization
phase, the executive gets and forwards executives to all its
descendants, before proceeding with application data processing.\\\\
The root processor, usually an embedded PC or other kind of workstation,
bootloads from its disk an operating system, which automatically loads
and executes a startup program allowing the user to choose between
different applications. During early developments, this program may be a
simple shell (but this requires a keyboard to be available), and the
user enters a "make" command to compile the executives if needed, and to
execute the root executive, with the other executive files passed as
arguments on the command line. In applications where it is unpractical
to use a keyboard permanently connected, the startup program may use
another input device (for example a switch or a touch screen) to let the
user choose between different predefined shell commands, starting
different applications through the corresponding "make" command, or
simply launching a shell for interaction with a keyboard. In more deeply
embedded applications, where the root processor has neither a disk nor
an operating system, all the executives are stored in a FLASH memory,
and the root processor boots by executing directly its own executive,
and finds the other executives sequentially stored in its FLASH.\\\\
The first executive forwarded to a descendant is received, stored, and
executed by that descendant's boot-loader. Then, while that descendant's
executive asks for executives, the ascendant executive gets and forwards
the next executives to the same descendant, until that descendant's
executive signals that it has itself no more executives to forward. Then
the ascendant may switch to its next descendant, until it has no more
descendant to service, and hence no more executive to forward. This
fully sequential download process boots processors in the order of a
depth-first traversal of the download tree.\\\\
In the case of a point-to-point medium, the descendant executive may
proceed to application data communications as soon as it has no more
executive to forward, whereas in the case of a multipoint medium, the
descendant executive must wait until the ascendant executive signals
that it has no more executive to forward (to avoid communication
interferences between descendant application data and ascendant download
data).

\section{Common Download Format}
Each processor type may have a different compiler (linker) output
format, and some processor types may have a ROM-ed embedded boot-loader
(firmware), with its own requirements on the download format. The SynDEx
common download format encapsulates the details and the differences of
the compiler output formats, and of the boot-loaders download formats;
it is composed as follows:
\begin{itemize}
\item four bytes prefix encoding the 32 bits big-endian total length of the following sequence of bytes
\item sequence of bytes, encoding one complete executive, structured as
  required by the destination boot-loader, and padded if needed with
  null bytes until the total length is a multiple of four.
\end{itemize}
The first executive forwarded to a descendant being received by that
descendant's boot-loader, that executive must be sent WITHOUT its four
bytes prefix; the following executives sent to the same descendant being
forwarded by that descendant's executive, they must be sent WITH their
four bytes prefix.\\\\
The sequence of bytes itself must follow the format
expected by the destination boot-loader. Therefore a linker
post-processor must be developped for each processor type, to translate
the linker output file into the SynDEx common dowload format described
above. All the post-processors' outputs will be concatenated by the
makefile into a unique contiguous image (file), that the root executive
will use as source.

\section{Downloader Macros}
The downloader code is generated by two macros:
\begin{itemize}
\item "loadFrom\_" starts the initialization phase of the communication
  sequence of the medium connected to the ascendant processor; its first
  argument is the name of the ascendant processor, its next arguments,
  if any, are the names of the other medium connected to descendant
  processors, if any;
\item "loadDnto\_" starts the initialization phase of the communication
  sequence of each medium connected to a descendant processor; its first
  argument is the name of the medium connected to the ascendant
  processor, its next argument(s) is (are) the name(s) of the descendant
  processor(s).
\end{itemize}
Processor names are usefull to address processors connected to
multipoint medium: a processor name may be suffixed to give the name of
a user defined macro, which substitution gives the processor address.\\\\
As executives data may be forwarded through several communication medium
of different bandwidths, transfers must be synchronized such that data
flow at the speed of the slowest medium.\\\\
Between processors, if flow control is not supported by the medium
hardware, it must be implemented by "ready to receive" control messages
sent by the loadFrom\_ code for each chunk of data to be sent by the
loadDnto\_ code. Inside a processor, the loadFrom\_ and loadDnto\_
macros cooperation is based on the order in which the spawn\_thread\_
macros (one for each communication sequence, i.e. for each communication
media) are generated in the initialization phase of the "main\_
... endmain\_" sequence: the spawn\_thread\_ macro corresponding to the
thread\_ macro of the communication sequence starting with the
loadFrom\_ macro (i.e. of the media connected to the ascendant
processor) is called first, followed by the other spawn\_thread\_
macros, among which the ones, if any, corresponding to the communication
sequences with a loadDnto\_ macro (i.e. of the media connected to the
descendant processors).\\\\
If the processor is a leaf node of the download tree, its loadFrom\_
macro has only one argument; in this case, it directly generates the
code sending to the ascendant processor a "null" message meaning that no
more executive is requested, followed, in the case of a multipoint
medium, by the code waiting for other executives to be downloaded to the
other processors connected to the medium, until the ascendant processor
sends an "empty" executive meaning that the download process is complete
on this medium.\\\\
Otherwise, before generating the code described in the previous
paragraph, the loadFrom\_ macro generates a RETURN instruction (which
will return control after the CALL instruction generated by the
spawn\_thread\_ macro), followed by a "loadFrom\_end\_:" label, and the
loadFrom\_ macro also defines three macros for use by the loadDnto\_
macros:
\begin{itemize}
\item the "loadFrom\_req\_" macro must generate the code that sends a
  "non-null" message requesting the ascendant processor to download
  another executive;
\item the "loadFrom\_get\_" macro must generate the code that receives
  one "word" of executive data from the ascendant processor; "word"
  means the size of a processor register, usually 32 bits; if the
  communication medium transfers executive data by chunks of N words,
  then every N calls to the code generated by the loadFrom\_get\_ macro
  receives a full chunk of data and returns its first word, and the next
  N-1 calls each return a next word of the chunk;
\item the "loadFrom\_next\_" macro, which is called at the end of each
  loadDnto\_ macro, must generate a "CALL loadFrom\_end\_", but only for
  the very last loadDnto\_ macro.
\end{itemize}
If the code generated by any of these three macros is limited to a few
instructions, it may be generated inline, otherwise the loadFrom\_ macro
generates this code as a subroutine (between the RETURN instruction and
the loadFrom\_end\_: label), and a call to that subroutine is generated
instead of the inline code.

\chapter{Links}
\htmladdnormallink{SynDEx : http://www-rocq.inria.fr/syndex}{http://www-rocq.inria.fr/syndex}\\\\
\htmladdnormallink{Objective Caml : http://caml.inria.fr/index-eng.html}{http://caml.inria.fr/index-eng.html}\\
\htmladdnormallink{Tcl/Tk : http://www.scriptics.com/}{http://www.scriptics.com/}\\
\htmladdnormallink{CamlTk :
  http://pauillac.inria.fr/camltk/}{http://pauillac.inria.fr/camltk/}\\
\htmladdnormallink{AAA methodology (SynDEx fundamentals) : http://www-rocq.inria.fr/syndex/pub/execv4/execv4.pdf}{http://www-rocq.inria.fr/syndex/pub/execv4/execv4.pdf}\\
\end{document}
