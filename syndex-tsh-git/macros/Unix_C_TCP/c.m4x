dnl (c)INRIA 2001
divert(-1)
# SynDEx v5 generic executive kernel customization for ANSI C monoprocessor.
ifdef(`syndex.m4x_already_included',,`errprint(
__file__:__line__: m4: syndex.m4x must be included before __file__!
)m4exit(1)')

ifdef(  __file__`_already_included',`error_(`already included')',
`define(__file__`_already_included')')

# ----------------------------------------------------------------------------
# This file defines all TARGET LANGUAGE DEPENDENT macros (prefixed by `basic')
# which customize the generic executive macros defined in the syndex.m4x file.
# SynDEx generates for each processor one macro-executive file starting with a
# `processor_' macro taking as argument the processor type, which is stored in
# the `processorType_' macro, and used to include the processorType_.m4x file.

# Application specific macros may be conditionned by `processorType_'
# to generate different codes for different target processor types;
# they may also be conditionned by `lang_' which may be defined
# identically by different processorType_.m4x files:

define(`lang_',`C')


############
# DATA TYPES

# --------
# typedef_(name, size) defines a new type with its size in address units:
typedef_(`bool',  1) # MUST be defined
typedef_(`char',  1) # SHOULD be defined
typedef_(`int',   4) # SHOULD be defined
typedef_(`uchar', 1) # SHOULD be defined
typedef_(`ushort',2) # SHOULD be defined
typedef_(`uint',  4) # SHOULD be defined
typedef_(`float', 4) # SHOULD be defined
typedef_(`double',8) # SHOULD be defined
typedef_(`FILE*', 4) # SHOULD be defined


###################
# MEMORY ALLOCATION

# -----------
# basicAlloc_(label, memoryBank)
define(`basicAlloc_', `define(`$1_base_', $1)dnl for `basicCopy_'
_($1_type_ $1[$1_size_];)')

# -----------
# basicAlias_(newLabel,oldLabel[,offset=0])
define(`basicAlias_', `
define(`$1_base_', $2_base_)dnl for `basicCopy_'
`#define' $1 ifelse($3,,`$2',`($2+$3)')')


##################
# MEMORY TRANSFERS

# ----------
# basicCopy_(destLabel,srceLabel,size)
# WARNING: memmove not available under SunOS-4 !?!
define(`basicCopy_', `ifelse($3,1,`_($1[0] = $2[0];)', `dnl check overlap:
_(ifelse($1_base_,$2_base_,memmove,memcpy)($1, $2, $3*sizeof(patsubst($2,`(&\([^[]*\)\[.*\])',`\1')_type_));)')')


####################
# CONTROL STRUCTURES

# --------
# basicIf_(buffer,value, tagforElseOrEndif)
define(`basicIf_', `_(if ($1[0]==$2) { /* $3 */)')

# -----------
# basicIfnot_(bool, tagForElseOrEndif)
# define(`basicIfnot_',`_(if(!$1[0]) { /* $2 */)')

# ----------
# basicElse_(tagFromIf, tagForEndif)
# define(`basicElse_', `_(/* $1 */ } else { /* $2 */)')

# -----------
# basicEndif_(tagFromIfOrElse)
define(`basicEndif_', `_(} /* end $1 */)')

# basicSwitch_(buffer, tagforElseOrEndif)
define(`basicSwitch_', `_(switch ($1[0]) { /* $2 */)')

# basicCase_(value, tagforElseOrEndif)
define(`basicCase_', `_(case $1 : /* $2 */)')

# basicEndCase_(tagforElseOrEndif) TARGET LANGUAGE DEPENDENT
define(`basicEndCase_', `_(break; /* $1 */)')

# basicEndSwitch_(tag_)`'indent_(+)')
define(`basicEndSwitch_', `_(} /* $1 */)')

# ----------
# basicLoop_(tagForEndloop)
define(`basicLoop_', `ifdef(`NBITERATIONS', `dnl fixed number of iterations
_({int i; for(i=0; i<NBITERATIONS; i++)){', `dnl otherwise forever
_(for(;;){)') /* $1 */')

# -------------
# basicEndloop_(tagFromLoop)
define(`basicEndloop_', `ifdef(`NBITERATIONS', `_(}})', `_(})') /* end $1 */')

# FG: ForLoop_ macro added    
# ----------
# basicForLoop_(tagForEndloop)
define(`basicForLoop_', `_({int i; for(i=0; i<$1; i++)){ /* $2 */')

# -------------
# basicEndForloop_(tagFromLoop)
define(`basicEndForloop_', `_(}}) /* end $2 */')

###############
# MAIN sequence

# ----------
# basicMain_()
define(`basicMain_', `dnl
_(int main(int argc, char* argv[]) { /* for link with C runtime boot */)')

# -------------
# basicEndmain_()
define(`basicEndmain_', `dnl
_(`  'return 0;)dnl
_(} /* end of main */)')


##################
# Subroutine calls
# For interfacing separately compiled C functions.

# ------
# Cdecl_(ret,label,args)
# Example m4 declaration and corresponding generated C code:
# Cdecl_(int, my_fun, int arg1, int* arg2, float arg3)
# | int my_fun(int arg1, int* arg2, float arg3);
def(`Cdecl_', `_(`$1 $2('shift(shift($@))`);')')

# ------
# Ccall_(ret,label,args)
# Example m4 declaration and macro-call with generated C code:
# def(`myfun', `Ccall_(int $3, my_fun, const 5, int *$1, float $2)')
# myfun(arg1,arg2,res) /* macro-call; generated code: */
# | res=myfun(5, arg1, arg2[0]);
define(`Ccall_', `dnl return value:
pushdef(`Ctyp_', patsubst($1,` .*'))dnl Extract argument type.
pushdef(`Carg_', patsubst($1,`.* +'))dnl Extract argument name.
ifelse(Ctyp_,`void',`_(`$2(')',`defined_(Carg_)_(Carg_`[0] = $2(')')dnl
Cargs_(shift(shift($@)))`);'popdef(`Carg_')popdef(`Ctyp_')')

# Cargs_([<type>[* ]<label>,]*)
define(`Cargs_', `ifelse($1,,,`dnl
define(`Ctyp_', patsubst($1,`[* ].*'))dnl Extract argument type.
define(`Carg_', patsubst($1,`.*[* ]+'))dnl Extract argument name.
ifelse(Ctyp_,`const',`Carg_', `dnl
defined_(Carg_)ifelse(Ctyp_,type_(Carg_),,dnl Check argument type.
`error_(`Expected type 'Ctyp_` for 'Carg_` which is of type 'type_(Carg_))')dnl
Carg_`'ifelse(index($1,*),-1, `[0]dnl argument passed by value')')`'dnl
ifelse(eval($#>1),1,`, ')dnl arguments are separated by commas.
Cargs_(shift($@))')')

# -------
# printf_(`formatString', argList) usable only if stdio supported.
def(`printf_', `printf("$1\n",shift($@));')

# scanf_(`type',index, variable) usable only if stdio supported.
# type can be float, int char or string

def(`scanf_', `ifelse(int,$1,`scanf("%d",&$3[$2]);dnl',
`ifelse(float,$1,`scanf("%f",&$3[$2]);dnl',
`ifelse(string,$1,`scanf("%s",&$3[$2]);dnl',`scanf("%c",&$3[$2]);dnl' )'
)' )') 

#######################################
# Standard user logic/arithmetic macros

define(`genLogic',`bool char uchar short ushort int uint long')
define(`genArith',`char uchar short ushort int uint long float double')
define(`genTypes',`bool  char uchar short ushort int uint long float double')

# generic unary operations for standard scalar and array types:
# -------
def(`gnot', `genUnary_(`~',genArith,$*)')dnl $2=~$1;
# -------
def(`gneg', `genUnary_(`-',genArith,$*)')dnl $2=-$1;

define(`genUnary_', `ifelse($#,4,,`error_(`Expected 2 arguments.')')dnl
mustBe(type_($4),`$2')proto_(pType_($4)?$3, pType_($4)!$4)dnl
ifelse($4_size_,1,`_($4[0] = $1$3[0];)',`dnl
_({ int i; for(i=0; i<$4_size_; i++))dnl
_(`  '$4[i] = $1$3[i];)dnl
_(})')')

# specific unary Logical not operation 
# -------
def(`gNOT', `ifelse($#,2,,`error_(`Expected 2 arguments.')')dnl
mustBe(type_($1),`bool') proto_(pType_($2)?$1, pType_($2)!$2)dnl
ifelse($2_size_,1,`_($2[0] = !$1[0];)',dnl
`_({ int i; for(i=0; i<$2_size_; i++))dnl
_(`  '$2[i] = !$1[i];)dnl
_(})')')

# generic unary Type cast operation for standard scalar and array types:
# -------
def(`gcast', `genTypeCast_(genTypes,$*)')dnl $2= ($2_type) $1;

define(`genTypeCast_', `ifelse($#,3,,`error_(`Expected 2 arguments.')')dnl
mustBe(type_($3),`$1')proto_(pType_($2)?$2, pType_($3)!$3)dnl
ifelse($3_size_,1,`_($3[0] = (pType_($3)) $2[0];)',`dnl
_({ int i; for(i=0; i<$3_size_; i++))dnl
_(`  '$3[i] = (type_($3)) $2[i];)dnl
_(})')')


# generic binary operations for standard scalar and array types:
# --------
def(`gmul',   `genBinary_(`*',genArith,$*)')dnl $3=$1*$2;
# --------    
def(`gdiv',   `genBinary_(`/',genArith,$*)')dnl $3=$1/$2;
# --------    
def(`gmod',   `genBinary_(`%',genLogic,$*)')dnl $3=$1%$2;
# --------    
def(`gadd',   `genBinary_(`+',genArith,$*)')dnl $3=$1+$2;
# --------    
def(`gsub',   `genBinary_(`-',genArith,$*)')dnl $3=$1-$2;
# --------   
def(`gand',   `genBinary_(`&',genLogic,$*)')dnl $3=$1&$2;
# --------    
def(`gor',    `genBinary_(`|',genLogic,$*)')dnl $3=$1|$2;
# --------    
def(`gxor',   `genBinary_(`^',genLogic,$*)')dnl $3=$1^$2;
# --------  
def(`grsh',   `genBinary_(`>>',genLogic,$*)')dnl $3=$1>>$2;
# --------
def(`glsh',   `genBinary_(`<<',genLogic,$*)')dnl $3=$1<<$2;

define(`genBinary_', `ifelse($#,5,,`error_(`Expected 3 arguments.')')dnl
mustBe(type_($5),`$2')proto_(pType_($5)?$3, pType_($5)?$4, pType_($5)!$5)dnl
ifelse($5_size_,1,`_($5[0] = $3[0] $1 $4[0];)',`dnl
_({ int i; for(i=0; i<$5_size_; i++))dnl
_(`  '$5[i] = $3[i] $1 $4[i];)dnl
_(})')')

# generic relational operations for standard scalar types:
# -------------
# -------------
def(`gEQ', `  genRelat_(`==',genTypes,$*)')dnl $3=$1==$2;
# -------------	   
def(`gNE', `  genRelat_(`!=',genTypes,$*)')dnl $3=$1!=$2;
# -------------	   
def(`gLT', `  genRelat_(`<', genArith,$*)')dnl $3=$1<$2;
# -------------	   
def(`gNL', `  genRelat_(`>=',genArith,$*)')dnl $3=$1>=$2;
# -------------	   
def(`gGT', `  genRelat_(`>', genArith,$*)')dnl $3=$1>$2;
# -------------
def(`gNG', `  genRelat_(`<=',genArith,$*)')dnl $3=$1<=$2;
# -------------	   
def(`gOR', `  genRelat_(`||', genArith,$*)')dnl $3=$1||$2;
# -------------	   
def(`gAND',`  genRelat_(`&&', genArith,$*)')dnl $3=$1&&$2;

define(`genRelat_',`ifelse($#,5,,`error_(`Expected 3 arguments.')')dnl
mustBe(type_($3),`$2')proto_(type_($3)?$3, type_($3)?$4, bool!$5)dnl
_($5[0] = $3[0] $1 $4[0];)')


################
# DSP operations

# --------
# gdotProd(type[N]?i1, type[N]?i2, type!ret)  ret=sum{i=0..N-1}(i1[i]*i2[i])
# Type may be either int, float or double.
# Returns the dot product of i1 and i2.  When used for FIR or IIR filters,
# one of i1 or i2 is a slidding window, the other is the coefficients array.
# For IIR filters, the input and output slidding windows are concatenated as
# are the two coefficient arrays, and the result is stored at the array end:
# concatenated coefficient arr:  Xn        X1     X0   Yk        Y1
# concatenated slidding window:  x[t-n] .. x[t-1] x[t] y[t-k] .. y[t-1] y[t]
#                                    new sample --^^^^         result --^^^^
def(`gdotProd', `ifelse($#,3,,`error_(`Expected 3 arguments')')dnl
mustBe(type_($1),`int float double')dnl
proto_(pType_($1)?$1, pType_($1)?$2, type_($1)!$3)dnl
_({ int i; for($3[0]=ifelse(type_($1),int,0,0.0), i=0; i<$1_size_; i++))dnl
_(`  '$3[0] += $1[i] * $2[i];)dnl
_(})')

# ---------
# gequalize(type[N]?coeff, type[N]?win, type?err, type[N]!coef)
# coef[0..N-1]-=win[0..N-1]*err
# Type may be either int, float or double.
def(`gequalize', `ifelse($#,4,,`error_(`Expected 4 arguments')')dnl
mustBe(type_($3),`int float double')dnl
proto_(pType_($1)?$1, pType_($1)?$2, type_($1)?$3, pType_($1)!$4)dnl
_({ int i; for(i=0; i<$1_size_; i++))dnl
_(`  '$4[i] = $1[i] - $2[i] * $3[0];)dnl
_(})')

ifelse(`dnl This second gequalize wont work until I&O are supported:
# gequalize(type?err, type[N]?win, type[N]?!coef) coef[0..N-1]-=win[0..N-1]*err
# Type may be either int, float or double.
def(`gequalize', `ifelse($#,3,,`error_(`Expected 3 arguments')')dnl
mustBe(type_($1),`int float double')dnl
proto_(type_($3)?$1, pType_($3)?$2, pType_($3)?!$3)dnl
_({ int i; for(i=0; i<$3_size_; i++))dnl
_(`  '$3[i] -= $2[i] * $1[0];)dnl
_(})')
')

######################
# CHRONOMETRIC LOGGING
# The macro Chrono_ is used in 4 different contexts, each differentiated by the
# value of the macro MGC (Macro-Generation-Context):
# - allocation: MGC is undefined, and therefore is substituted by itself,
#   Chrono_ allocates a circular buffer for logging chronometric data,
#   and defines the GetTime function to get the timer current value;
# - initialization: MGC is defined as `INIT' by the macro `main_',
#   Chrono_ initializes the timer, the circular buffer and its pointer;
# - iteration: MGC is defined as `LOOP' by the macro `loop_',
#   Chrono_ logs the current timer value together with the log-point identifier
#   that Chrono_ receives as argument;
# - finalization: MGC is defined as `END' by the macro `endloop_',
#   Chrono_ finalizes the timer and dumps chronometric data in mass memory.

# -----------------
# Chrono_GetTime_() ; defines separately the C function "GetTime",
#                     such that the default Unix definition may be
#                     overriden by a user-defined macro.
define(`Chrono_GetTime_',`
#include<sys/time.h>
int GetTime(void) { /* return system clock current time (microseconds) */
  struct timeval t;
  gettimeofday(&t,(void*)0);
  return (int)(1000000*t.tv_sec+t.tv_usec);
}
')

# ---------
# Chrono_() ; allocate/init/record/dump chronometric data
def(`Chrono_', `ifelse(
MGC,`MGC',`dnl ALLOC: $1=number of (label,date) records
dnl `typedef struct {' opened by `semaphores_'
ifdef(`sp_struct_opened',`} shmemory; /* end of shared data */
shmemory* sp; /* the mapped base address of the shared memory area */
undefine(`sp_struct_opened')')

Chrono_GetTime_()
/* Chronometric data */
typedef struct{int label, date;} Chrono_record_;
#define Chrono_size_ $1*3
Chrono_record_ Chrono_base_[Chrono_size_]={}; /* zeroed by ANSI C */
Chrono_record_ *Chrono_current_=Chrono_base_;
void Chrono_lap_(int label) /* record current date with label */
{ Chrono_current_->label=label;
  Chrono_current_->date=GetTime();
  if(++Chrono_current_==Chrono_base_+Chrono_size_)
    Chrono_current_=Chrono_base_;
}
#include <stdio.h>
#define Chrono_overhead_ 1
void Chrono_store_(Chrono_record_ *p) { /* store one chronometric record */
  static int date=0; /* display label, date, delta */
  if(date==0){
    printf("Chronometric profiling:\n");
    printf("label date dt=date-datePrec-chronoOverhead (microseconds)\n");
    printf("%d %d chronoOverhead=%d\n", p->label, p->date, Chrono_overhead_);
  }
  else printf("%d %d %d\n", p->label, p->date, p->date-date-Chrono_overhead_);
  date=p->date;
}
',
MGC,`INIT',`',
MGC,`LOOP', `Chrono_lap_($1);divert(127)
chrono $1 = $2 dnl $1=labelNumber $2=labelName
divert',
MGC,`END',`
{ /* dump all chronometric records */
  Chrono_record_* p=Chrono_current_;
  if(p->label != 0) do Chrono_store_(p);
  while(++p != Chrono_base_+Chrono_size_);
  for(p=Chrono_base_; p!=Chrono_current_; p++) Chrono_store_(p);
  /**********************************************
   Chronometric labels number/name correspondence: undivert(127)
  ***********************************************/
  printf("Use ``grep \"^chrono\" *.c'' to collect labels number/name correspondences\n");
}')')

divert
typedef enum {false=0, true=1} bool;

divert`'dnl ---------------------- End of file -------------------------


