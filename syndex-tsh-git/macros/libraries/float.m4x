dnl int library
divert(-1)

# ###### *** ARITHMETIC *** ######

# Negative/Minus
def_lib(`Arit_minus',`ifelse(MGC,`LOOP',`gneg(shift($@))')')

# Multiply
def_lib(`Arit_mul',`ifelse(MGC,`LOOP',`gmul(shift($@))')')

# Divide
def_lib(`Arit_div',`ifelse(MGC,`LOOP',`gdiv(shift($@))')')

# Add
def_lib(`Arit_add', `ifelse(MGC,`LOOP',`gadd(shift($@))')')

# Substract
def_lib(`Arit_sub',`ifelse(MGC,`LOOP',`gsub(shift($@))')')

# ###### *** BITWISE *** ######

# Bitwise Not (one's complement)
def_lib(`Bit_not', `ifelse(MGC,`LOOP',`gnot(shift($@))')')

# Bitwise And
def_lib(`Bit_and', `ifelse(MGC,`LOOP',`gand(shift($@))')')

# Bitwise Or
def_lib(`Bit_or', `ifelse(MGC,`LOOP',`gor(shift($@))')')

# Bitwise Xor
def_lib(`Bit_xor', `ifelse(MGC,`LOOP',`gxor(shift($@))')')

# Bitwise Rshift
def_lib(`Bit_rsh', `ifelse(MGC,`LOOP',`grsh(shift($@))')')

# Bitwise Lshift
def_lib(`Bit_lsh', `ifelse(MGC,`LOOP',`glsh(shift($@))')')

# ###### *** LOGIC *** ######

# Logical negation 
def_lib(`Log_not', `ifelse(MGC,`LOOP',`gNOT($*)')')

# Logical And
def_lib(`Log_and', `ifelse(MGC,`LOOP',`gAND($*)')')

# Logical Or
def_lib(`Log_or',  `ifelse(MGC,`LOOP',`gOR($*)')')

# Logical Equality
def_lib(`Log_eq',  `ifelse(MGC,`LOOP',`gEQ($*)')')

# Logical Inequality
def_lib(`Log_ne',  `ifelse(MGC,`LOOP',`gNE($*)')')

# Logical Greater Than
def_lib(`Log_gt',  `ifelse(MGC,`LOOP',`gGT($*)')')

# Logical Not Greater Than
def_lib(`Log_ngt', `ifelse(MGC,`LOOP',`gNG($*)')')

# Logical Less Than
def_lib(`Log_lt',  `ifelse(MGC,`LOOP',`gLT($*)')')

# Logical Not Less Than
def_lib(`Log_nlt', `ifelse(MGC,`LOOP',`gNL($*)')')

# ###### *** TYPE CAST *** ######
def_lib(`float2bool', `ifelse(MGC,`LOOP',`gcast($*)')')
def_lib(`float2int', `ifelse(MGC,`LOOP',`gcast($*)')')

# ###### *** DELAY *** ######

# delay
define(`f_delay',`ifelse(0,$1,,`buffer_[eval($1-1)]=last_($@);dnl
_(f_delay(eval($1-1),shift_R_($@)))')')

def_lib(`delay',`dnl
define(`buffer_',last_($@))dnl
ifelse(MGC,`INIT',`f_delay(shift_R_(shift_R_(shift_R_($@))))')')

# window
def_lib(`window',`ifelse(dnl
MGC,`INIT',`_(zero_($4))',dnl
MGC,`LOOP',`_(shift_($4,$3))',dnl
MGC,`END',`')')


# ######## *** I/O *** ########

# Constant
define(`f_cst',`ifelse(0,$1,,`buffer_[eval($1-1)]=last_($@);dnl
_(f_cst(eval($1-1),shift_R_($@)))')')

def_lib(`cst',`ifelse($#,eval($1+2),,`error_(`Expected eval($1+2) arguments.')')dnl
define(`buffer_',last_($@))dnl
ifelse(MGC,`INIT',`f_cst(shift_R_($@))')')

# Sensor

define(`f_input_f',`ifelse(0,$1,`printf_(%s,"\n");',`printf_($2[%d]: ,eval($1-1));dnl
scanf_(float,eval($1-1),last_($@));dnl 
_(f_input_f(eval($1-1),last_($@)))')')

def_lib(`input',`ifelse(dnl
MGC,`INIT',`',dnl
MGC,`LOOP',`f_input_f($@)',
MGC,`END',`dnl')')


# Actuator

define(`f_output_f',`ifelse(0,$1,`printf_(%s,"\n");',`printf_($2[%d] : %f,eval($1-1),$2[eval($1-1)]);dnl
_(f_output_f(eval($1-1),last_($@)))')')

def_lib(`output',`ifelse(dnl
MGC,`INIT',`dnl',
MGC,`LOOP',`f_output_f($@)',
MGC,`END',`dnl')')


# ######## *** DSP operations *** ########

# dotProduct
def_lib(`dotProduct', `ifelse(dnl
MGC,`INIT',`zero_(last_($*))',dnl
MGC,`LOOP',`gdotProd(shift($*))')')

# equalize
def_lib(`equalize', `ifelse(MGC,`LOOP',`gequalize($*)')')

# equalize
def_lib(`equalize2', `ifelse(MGC,`LOOP',`gequalize2($*)')')

divert`'dnl ---------------------- End of file -------------------------















