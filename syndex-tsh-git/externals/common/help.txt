







                     ************ SSyynnddeexx vv66 -- UUsseerr MMaannuuaall ************
                JJuulliieenn FFoorrggeett,, CChhrriissttoopphhee LLaavvaarreennnnee,, YYvveess SSoorreell
                               NNoovveemmbbeerr 2288,, 22000033

********** CCoonntteennttss **********
    * _1_._ _O_v_e_r_v_i_e_w
    * _2_._ _G_e_t_t_i_n_g_ _s_t_a_r_t_e_d
    * _3_._ _L_i_b_r_a_r_i_e_s
    * _4_._ _U_s_i_n_g_ _t_h_e_ _i_n_t_e_r_f_a_c_e
          o _4_._1_ _C_o_n_t_e_x_t_u_a_l_ _m_e_n_u_s
          o _4_._2_ _S_e_l_e_c_t_i_o_n
          o _4_._3_ _Z_o_o_m
          o _4_._4_ _C_o_n_t_e_x_t_u_a_l_ _i_n_f_o_r_m_a_t_i_o_n_s
          o _4_._5_ _R_e_t_r_i_e_v_i_n_g_ _a_ _v_e_r_t_e_x_ _i_n_ _a_ _c_o_m_p_l_e_x_ _g_r_a_p_h
          o _4_._6_ _G_r_a_p_h_ _e_l_e_m_e_n_t_s_ _b_e_c_o_m_i_n_g_ _i_n_a_c_t_i_v_e

    * _5_._ _A_l_g_o_r_i_t_h_m
          o _5_._1_ _T_o_ _c_r_e_a_t_e_ _a_n_ _a_l_g_o_r_i_t_h_m_ _d_e_f_i_n_i_t_i_o_n
          o _5_._2_ _T_o_ _c_o_n_d_i_t_i_o_n_ _a_n_ _a_l_g_o_r_i_t_h_m_ _d_e_f_i_n_i_t_i_o_n
          o _5_._3_ _T_o_ _r_e_p_e_a_t_ _a_n_ _a_l_g_o_r_i_t_h_m_ _d_e_f_i_n_i_t_i_o_n
                # _5_._3_._1_ _I_m_p_l_i_c_i_t_ _r_e_p_e_t_i_t_i_o_n_ _s_p_e_c_i_f_i_c_a_t_i_o_n
                # _5_._3_._2_ _E_x_p_l_i_c_i_t_ _r_e_p_e_t_i_t_i_o_n_ _s_p_e_c_i_f_i_c_a_t_i_o_n
                # _5_._3_._3_ _E_x_p_l_i_c_i_t_ _v_e_r_s_u_s_ _i_m_p_l_i_c_i_t
          o _5_._4_ _T_o_ _m_o_d_i_f_y_ _a_n_ _a_l_g_o_r_i_t_h_m_ _d_e_f_i_n_i_t_i_o_n_ _o_r_ _a_ _r_e_f_e_r_e_n_c_e
          o _5_._5_ _T_o_ _d_e_l_e_t_e_ _a_n_ _a_l_g_o_r_i_t_h_m_ _d_e_f_i_n_i_t_i_o_n

    * _6_._ _A_r_c_h_i_t_e_c_t_u_r_e
          o _6_._1_ _O_p_e_r_a_t_o_r
                # _6_._1_._1_ _T_o_ _c_r_e_a_t_e_ _a_n_ _o_p_e_r_a_t_o_r_ _d_e_f_i_n_i_t_i_o_n
                # _6_._1_._2_ _T_o_ _m_o_d_i_f_y_ _a_n_ _o_p_e_r_a_t_o_r_ _d_e_f_i_n_i_t_i_o_n
                # _6_._1_._3_ _T_o_ _d_e_l_e_t_e_ _a_n_ _o_p_e_r_a_t_o_r_ _d_e_f_i_n_i_t_i_o_n
          o _6_._2_ _M_e_d_i_u_m
                # _6_._2_._1_ _T_o_ _c_r_e_a_t_e_ _a_ _m_e_d_i_u_m_ _d_e_f_i_n_i_t_i_o_n
                # _6_._2_._2_ _T_o_ _m_o_d_i_f_y_ _a_ _m_e_d_i_u_m_ _d_e_f_i_n_i_t_i_o_n
                # _6_._2_._3_ _T_o_ _d_e_l_e_t_e_ _a_ _m_e_d_i_u_m_ _d_e_f_i_n_i_t_i_o_n
          o _6_._3_ _A_r_c_h_i_t_e_c_t_u_r_e
                # _6_._3_._1_ _T_o_ _c_r_e_a_t_e_ _a_n_ _a_r_c_h_i_t_e_c_t_u_r_e_ _d_e_f_i_n_i_t_i_o_n
                # _6_._3_._2_ _T_o_ _m_o_d_i_f_y_ _a_n_ _a_r_c_h_i_t_e_c_t_u_r_e_ _d_e_f_i_n_i_t_i_o_n
                # _6_._3_._3_ _T_o_ _d_e_l_e_t_e_ _a_n_ _a_r_c_h_i_t_e_c_t_u_r_e_ _d_e_f_i_n_i_t_i_o_n

    * _7_._ _C_h_a_r_a_c_t_e_r_i_s_t_i_c_s
    * _8_._ _C_o_n_s_t_r_a_i_n_t_s
    * _9_._ _A_d_e_q_u_a_t_i_o_n
    * _1_0_._ _C_o_d_e_ _g_e_n_e_r_a_t_i_o_n
          o _1_0_._1_ _O_v_e_r_v_i_e_w
          o _1_0_._2_ _H_o_w_ _t_o_ _C_o_m_p_i_l_e_ _a_n_ _E_x_e_c_u_t_i_v_e
          o _1_0_._3_ _H_o_w_ _t_o_ _L_o_a_d_ _t_h_e_ _C_o_m_p_i_l_e_d_ _E_x_e_c_u_t_i_v_e
          o _1_0_._4_ _H_o_w_ _t_o_ _A_u_t_o_m_a_t_e_ _t_h_e_ _C_o_m_p_i_l_a_t_i_o_n_/_L_o_a_d_ _P_r_o_c_e_s_s

    * _1_1_._ _S_y_n_D_E_x_ _D_o_w_n_l_o_a_d_e_r_ _S_p_e_c_i_f_i_c_a_t_i_o_n
          o _1_1_._1_ _C_o_n_t_e_x_t
          o _1_1_._2_ _B_o_o_t_ _a_n_d_ _D_o_w_n_l_o_a_d_ _P_r_o_c_e_s_s
          o _1_1_._3_ _C_o_m_m_o_n_ _D_o_w_n_l_o_a_d_ _F_o_r_m_a_t
          o _1_1_._4_ _D_o_w_n_l_o_a_d_e_r_ _M_a_c_r_o_s

    * _1_2_._ _L_i_n_k_s
************ 11.. OOvveerrvviieeww ************
A SynDEx application is made of algorithm graphs (definitions of operations
that the application may execute) and architecture graphs (definitions of
multicomponents: set of interconnected processors and specific integrated
circuits). Performing an adequation means to execute heuristics seeking for an
optimized implementation of a given algorithm onto a given architecture.

"Adequation" means an efficient mapping. An implementation consists in
distributing (allocate parts of algorithm onto components) and scheduling (give
a total order for the operations distributed onto a component) the algorithm
onto the architecture.

SynDEx runs under Linux, Solaris and Windows platforms.

SynDEx is written in _O_b_j_e_c_t_i_v_e_ _C_a_m_l. The GUI is written in _T_c_l_/_T_k with the
OCaml library _C_a_m_l_T_k.
************ 22.. GGeettttiinngg ssttaarrtteedd ************
To create an application workspace, run the syndex-6.?.? executable, located at
the root of your installation directory. This will open the principal window of
SynDEx. Be sure to read the README if you have some troubleshooting.

To open an existing application and thus fill the workspace, choose in the
principal window the OPEN option from the menu FILE, and then choose an
"applicationName.sdx" file. This will open the (main) algorithm window and the
(main) architecture window if they have been defined. "(main)" means that it is
on these two graphs that the adequation will be applied. Opening another
application replaces the present application by the new one in the workspace.

To close an application, choose in this principal window the CLOSE option from
the menu FILE. This will close all the windows and leave the workspace empty.

To save an application with its current name, choose in the principal window
the SAVE option from the menu FILE.

To save an application with a new name, choose in the principal window the SAVE
AS option from the menu FILE. This will open a standard browsing window in
order to choose the new name.

Notice that you can save the result of the last adequation you computed with
your application by enabling the option SAVE ADEQUATION RESULT in the OPTIONS
menu. Next time you will load the application, you will not have to recompute
the adequation.

To quit the application, choose in the principal window the QUIT option from
the menu FILE.
************ 33.. LLiibbrraarriieess ************
To create a new application you may want to use predefined algorithm
definitions, operators or media. To include a library in an application in
order to make references to the objects it contains, choose the option INCLUDE
LIBRARY from the menu FILE of the principal window. You can un-include an
included library the same way, provided there are no references in your
application on definitions of this library.

To create libraries of algorithm definitions or operators or media, you must
create a file .sdx containing the definitions you need. These libraries must be
located in a directory named "libs", by default located at the root of your
install directory, or which location may be specified with the "-libs" option
of the SynDEx command line (in the script used to launch SynDEx).

************ 44.. UUssiinngg tthhee iinntteerrffaaccee ************
************ 44..11 CCoonntteexxttuuaall mmeennuuss ************
To open a contextual menu on a window, point the cursor at the window
background, then click the right button of the mouse and choose the appropriate
option. This allows you to perform most of the actions described in the EDIT
menus of the corresponding window. These menus mainly include edition commands
(cut, paste, copy, etc) and a useful INFO BUBBLES option which displays
additionnal information when you point to a vertice of your graph (either
algorithm, architecture or adequation schedule view).

To open a contextual menu on a vertex, an edge or a port, point the cursor of
the mouse on the object, then click the right button of the mouse and choose
the appropriate option. This allows you to perform most of the actions
described in the EDIT menus.
************ 44..22 SSeelleeccttiioonn ************
Selection may be applied to vertices or edges of both algorithm or architecture
graphs.

To select one vertex, point the cursor at this vertex which borders will appear
red highlighted, click the left button of the mouse. When a vertex is selected
small black squares appear at each corner of the vertex. To select
incrementally vertices, click them while pressing SHIFT key. Selecting an
already selected vertex will un-select it. You may select a group of vertices
by pressing the right button of the mouse while dragging it, in order to draw a
square when the button is released. Vertices inside or intersecting the square
are selected.

To move a selection, point the cursor at a vertex of this selection, click the
left button of the mouse and drag until the next position. When the button is
released the selection remains at this position.

To cancel a selection click outside this selection.

To cut, copy, paste, a selection, as usual choose the corresponding options in
the menu EDIT of the corresponding window, or respectively use the classical
short-cut key: Ctrl-X, Ctrl-C, Ctrl-V.
************ 44..33 ZZoooomm ************
Zoom may be applied to algorithm, architecture or timing windows by moving the
zoom cursor on the border of the windows.
************ 44..44 CCoonntteexxttuuaall iinnffoorrmmaattiioonnss ************
When the cursor points at an object of an algorithm, an architecture or a
timing window, information is displayed in the principal window.

By default information is not kept when you switch between objects. The new
information overwrites the older one. You can change this behaviour and keep
all the information by enabling the option KEEP INFORMATION IN MAIN WINDOW
(shortcut Ctrl-K) in the OPTIONS menu. This is for instance useful when the
information displayed does not fit in the window, which requires you to scroll
the main window.
************ 44..55 RReettrriieevviinngg aa vveerrtteexx iinn aa ccoommpplleexx ggrraapphh ************
Looking for a vertex, from which you now the name, in a complex graph can
become rather tedious. In the algorithm, architecture and adequation result
windows, you can use the commands FIND REFERENCE/PORT/OPERATION/OPERATOR/
MEDIUM, to locate a vertex of your graph by its name. This will open a window
listing all the vertices of your graph. Double-clicking on one of them will
select it.
************ 44..66 GGrraapphh eelleemmeennttss bbeeccoommiinngg iinnaaccttiivvee ************
Sometimes, you will notice that some elements of a graph, that is to say
vertices or edges, become ``inactive''. For instance, you can't move a vertice
or select a port anymore. In such a case, use the refresh command (shortcut
Ctrl-R) which will bring the graph behaviour back to normal.
************ 55.. AAllggoorriitthhmm ************
In AAA methodology, an algorithm is specified as a directed acyclic graph (DAG)
infinitely repeated. Directed means that for each edge representing a relation
between vertices, the vertices n-uple is ordered, i.e. its first element is the
source vertex the other one(s) is (are) the destination vertex(ices).

Still in AAA, vertices are operations; operation stands for a sequence of
instructions which starts after all its input data is available and produces
output data at the end of the sequence. In SynDEx, there is an additionnal
notion of reference. To each reference corresponds the definition of an
algorithm (we will say ``definition'' instead of ``algorithm definition'' for
the rest of this chapter). The same definition may correspond to several
references to this definition. An algorithm definition is a DAG similar to
those in AAA, except that vertices are references or ports. A reference in a
definition may correspond to a definition which contains several references and
so on. Ports are used only for propagating back and forth edges along the
hierarchy.

In SynDEx, algorithms can be defined through hierarchy. A definition is said
hierarchical when it defines (explicitly or implicitly) an algorithm which
contains at least one dependence (and possibly references), otherwise it is
said atomic.

A definition is said explicitly hierarchical when the algorithm specified by
the user contains at least one edge (and possibly references). This includes
conditioning, repetitions of hierarchical definitions and, more generally,
definitions defined through several levels of hierarchy.

A definition is said implicitly hierarchical when the algorithm specified by
the user doesn't contain any dependence and yet will be transformed by SynDEx,
for the adequation, into a graph which contains dependences. This happens only
with repetitions of atomic definitions.

In a definition window, references to a definition explicitly hierarchical are
displayed with a double-border, references to conditioned definitions have
their conditioning port displayed in yellow and the repetition factor of a
reference is displayed next to to the references name.

There are five types of definitions: constant (input vertex of the DAG, null
execution time) and sensor (input vertex of the DAG producing data from a
physical sensor) which both have no input ports, actuator (output vertex of the
DAG consuming data for a physical sensor) which has no output port, function
(reads data on input ports, executes instructions without any side-effect,
writes data on output ports), and delay (memorizes data during one or several
infinite repetition of the DAG, for use in next repetitions). Only a function
may be defined through explicit hierarchy.

WARNING: A hierarchical definition does not have to wait for all its input data
to be available before starting some computations. Indeed, parts of the
algorithm graph of a hierarchical algorithm definition may only require parts
of the input data of the definition and therefore can start as soon as this
part is available (and not all the data). In the same way, some data may be
produced before the end of the complete sequence of computations.

There are two types of edges: strong data communication and execution
precedence, or execution precedence only. The first type imposes that the
reference, at the source of the dependence, produces data and is executed
before the reference, at the destination of the dependence, which consumes the
data. The second type only imposes an execution order between references, no
data is produced or consumed.

In a definition window, to open the definition corresponding to a reference in
order to inspect and possibly modify its content, point the cursor at this
reference which borders will highlight in red, then double click the left
button of the mouse. This will display the graph of the definition in a new
window.

To label an algorithm window with "(main)", choose MAIN DEFINITION in the EDIT
menu. Notice that the algorithm (main) must be at the root level of a
hierarchy; it can't contain ports.

To open the algorithm (main) definition, choose the option EDIT MAIN DEFINITION
in the menu ALGORITHM of the principal window.
************ 55..11 TToo ccrreeaattee aann aallggoorriitthhmm ddeeffiinniittiioonn ************
To create a new local definition, choose the option NEW LOCAL DEFINITION /
FUNCTION-CONSTANT-SENSOR-ACTUATOR-DELAY in the menu ALGORITHM of the principal
window, this will open a window for text edition in order to input its name and
possibly a list of parameter names, and will create a new definition window
labeled "name".

The paramater are used to create more generic definitions (for example for the
ports of type array, to parametrize the dimension of the array) and are
separated by semi-colons.

Delay definitions must have a single input/output port and at least one
parameter. This parameter, called the delay range (N) is the number of graph
repetitions during which values will be memorized. It must be the last
parameter of this definition. Be aware that the delay must have initial values
for the N first infinite repetitions of the graph either by using a parameter
for these initial values or by initialising it in the macro-code.

Now you may construct a graph with references to constants, sensors, actuators,
delays and function. If this definition is intended to be referenced in an
explicit hierarchy, i.e. this reference will belong to a certain level of
hierarchy (possibly a leaf), you must use input and output ports. If this
definition is intended to be referenced at the root level of the hierarchy,
input ports are replaced by sensors and output ports are replaced by actuators.


To create an input or an output port, choose the option CREATE PORT in the menu
EDIT of the definition window, this will open a window for text edition in
order to input for each port its name, direction (input, output, or input/
output), and type that you can arbitrarily define: for example integer or int,
float, bool, ... or array of integer, float, bool, ... WARNING: each type must
be associated to a duration (cf. chapter _7). Array types are specified with the
classical square brackets delimiter. You can use a parameter to specify the
size of an array port. You can either directly use the name of the parameter
between the square brackets if the parameter is an integer (e.g. ``? float
[N] i'') or put the name of the parameter between pipes for the length of the
parameter if the parameter is a list (e.g. ``? float[|L|] i''). Parameter
values won't be evaluated by SynDEx until you choose a main algorithm.

If you plan to generate code, it is necessary to specify an order for the
ports, consistent with the declaration of the corresponding executable
function. To specify the ports order, choose the option PORTS ORDER of the
contextual menu.

To create a reference to a definition, choose the option CREATE REFERENCE in
the menu EDIT of the definition window, this will open a window for text
edition in order to input the reference name and possibly a list of arguments
values and a repetition factor. Arguments can be lists, separated by semi-
colons. Values in lists are separated by comas and the whole list is delimited
with round brackets (e.g. ``delay <{5,6,4,3};2>''). For the repetition factor,
see section ``To modify an algorithm definition or a reference''.

To create dependences between references or ports, point the cursor at an
output of the source reference, or at an input port, and click the middle
button of the mouse (or CTRL+click the left button of the mouse) and drag to an
input of a destination reference, or at an output port. When the button is
released the edge will be drawn. Notice that you can point on the name of the
port and not only on the small black square.

Connecting two vertices will create a dependence which type is the default
type. To set the default type of the dependences choose DEFAULT EDGE TYPE in
the menu EDIT of the definition window.

To change an edge type, point the cursor at this edge which will highlight,
then click the right button of the mouse and choose the new type.
************ 55..22 TToo ccoonnddiittiioonn aann aallggoorriitthhmm ddeeffiinniittiioonn ************
To condition a definition, choose the command CREATE CONDITION in the EDIT menu
of the definition window, this will open a window for text edition in order to
input the name and the values the conditioning may take. The name of the
conditioning must be the name of an existing input port of type integer. The
conditioning is a list, where each element, separated by spaces, is the name of
the conditioning port and the value it may take, separated by ``='' (e.g.
``cond=1 cond=2 cond=3''). This specific port must be unique for a definition.
Once you have created a conditioning, the conditioning port is colored yellow.

Each value the conditioning may take, will have a corresponding button at the
top of the definition window. After selecting one value by clicking on the
corresponding button, you will have to construct a graph. This graph describes
the algorithm executed when the conditioning takes this value. During the
execution, only the graph corresponding to the value that the conditioning port
will have, will be executed.
************ 55..33 TToo rreeppeeaatt aann aallggoorriitthhmm ddeeffiinniittiioonn ************
********** 55..33..11 IImmpplliicciitt rreeppeettiittiioonn ssppeecciiffiiccaattiioonn **********
In most cases, to repeat an algorithm definition, you should use the implicit
repetition specification. Create a reference to a definition such that the
number of elements of the type of each input is an exact divisor (submultiple)
of the number of elements of the type of the corresponding output it is
connected to, and similarly, the number of elements of the type of each ouput
is a sub-multiple of the number of elements of the type of the corresponding
input it is connected to. The ratio between the number of elements of each
input (resp. output) and the number of elements of the output (resp. input) it
is connected to, gives the number of repetitions; we call this situation a
Fork-Join. WARNING: all the ratios of the repeated definition must be the same,
otherwise it is not consistent. However, some inputs may have ratio one,
whereas the common ratio is greater than one, in this case the input is
replicated as much time as the common ratio; we call this situation Diffuse.
Similarly, some outputs may have ratio one, whereas the common ratio is greater
than one, in this case the output of the repetition i becomes the input of the
repetition i+1, and the definition must have a corresponding input/output port,
which SynDEx will use to connect the successive repetitions; we call this
situation Iterate. The output of the last repetition is the output of the
repeated definition. Input/output port must be initialized.

Hence, the number of repetition applied to the definition is implicit, it is
calculated by SynDEx which will automatically repeat the algorithm definition
and create the corresponding expanded graph. The repetition factor is displayed
next to the name of the reference. It is the expanded graph which will be taken
into account during the adequation and the code generation. The expansion will
introduce new vertices called explode and implode. The explode vertex extracts
for each repetition of a definition each element of the data it receives,
whereas the implode vertex builds the data it sends by concatenating each
separated element produced by each repetition of the definition.

Suppose that you want to specify the multiplication of a vector V by a scalar S
giving a vector W as result. You can specify it using the multiplication
between two scalars instead of defining a new multiplication between a vector
and a scalar. By the way, this allows you to specify more parallelism. For
example if the dimension of the vector is three, you may specify the repetition
by three multiplications between two reals giving a real as a result, by
referencing this definition and connecting one of the two inputs to an output
which is a vector of three real (V), and the other input to an output of one
real (S), and connecting its output to an input which is a vector of three
reals (W). The common ratio is three, and one input has a ratio one that is to
say the real is replicated three times in order to be multiplicated by one of
the three elements of the vector.
********** 55..33..22 EExxpplliicciitt rreeppeettiittiioonn ssppeecciiffiiccaattiioonn **********
In some cases, you may want to specify a repetition of a definition but have no
difference between port sizes. You must then use explicit repetition
specification instead of the implicit specification. Create a reference to the
definition and specify a repetition factor in the reference creation window.
The repetition factor is specified after the reference name and the optional
arguments list, and is also optional. The repetition is specified as an integer
between square brackets. For instance, ``minus [3]'' specifies three repetition
of definition.

It is important to notice that with explicit repetition you can only express
the Diffuse and Iterate situation, as all port ratios equal one.
********** 55..33..33 EExxpplliicciitt vveerrssuuss iimmpplliicciitt **********
Implicit repetition is prioritary to explicit repetition for consistancy
purposes. Therefore, you can't specify an explicit repetition on a definition
which is already implicitly repeated. The port ratios would not be consistant
anymore.

Furthermore, if you perform some actions on your algorithm graph which cause
the port ratios of a definition explicitly repeated to change, the definition
becomes implicitly repeated and the explicit repetition factor is lost.
************ 55..44 TToo mmooddiiffyy aann aallggoorriitthhmm ddeeffiinniittiioonn oorr aa rreeffeerreennccee ************
To open a definition, choose the option EDIT DEFINITION in the menu ALGORITHM
of the principal window, you may also point at a reference in a definition
window and double click when highlighted. In both cases this will open a
definition window.

To modify a local definition, use one option of the EDIT menu in order to
create input and output ports, references to constants, sensors, actuators,
memories and operations.

To modify the definitions of a library, open the file of this library which is
in the directory "libs", by using the option OPEN of the menu FILE. It is not
possible to modify the definitions of a library when you are working in an
application which includes this library. Be aware that changes in a definition
are considered for all references on it. In particular, changing a definition
in a library may have consequences on several applications using this library.

To modify a reference, use the contextual menu related to the reference. To
obtain this contextual menu point at a reference which borders will highlight
in red, then click the right button of the mouse.
************ 55..55 TToo ddeelleettee aann aallggoorriitthhmm ddeeffiinniittiioonn ************
To delete a local definition choose the option DELETE LOCAL DEFINITION in the
menu ALGORITHM of the principal window.
************ 66.. AArrcchhiitteeccttuurree ************
An architecture is specified as a non directed graph where vertices are of two
types: operator or medium, and each edge is a connection between an operator
and a medium.

To label an architecture window with "(main)", choose MAIN ARCHITECTURE in the
EDIT menu.

To open the architecture (main), choose the option EDIT MAIN ARCHITECTURE in
the menu ARCHITECTURE of the principal window.
************ 66..11 OOppeerraattoorr ************
********** 66..11..11 TToo ccrreeaattee aann ooppeerraattoorr ddeeffiinniittiioonn **********
To create a new operator definition, choose the option NEW LOCAL OPERATOR
DEFINITION in the menu ARCHITECTURE of the principal window, this will open a
window for text edition in order to input a name to this new operator
definition. This will open a definition window in which you may modify the
gates list and the operation durations list of the operator.

In the gates list window, you specify the gate type and the gate name separated
by a space (e.g. ``TCP x''); one gate per line.

In the durations list window, you specify the definition name and its duration,
which is an integer, separated by a ``='' (e.g. ``add = 1''); one duration per
line. Notice that when the duration for a definition ``algo'' has already been
specified in an included library ``lib'' the duration will appear in the
duration window as ``lib/algo = ...''. You should not modify this duration
directly in your application (it will not be saved). As it belongs to the
library, modify the library itself instead (but the modification will be taken
into account for all the applications including it).
********** 66..11..22 TToo mmooddiiffyy aann ooppeerraattoorr ddeeffiinniittiioonn **********
To modify an existing local or global library operator definition, choose the
option EDIT OPERATOR DEFINITION in the menu ARCHITECTURE of the principal
window, this will open a definition window.
********** 66..11..33 TToo ddeelleettee aann ooppeerraattoorr ddeeffiinniittiioonn **********
To delete a local operator definition choose the option DELETE LOCAL OPERATOR
in the menu ARCHITECTURE of the principal window.
************ 66..22 MMeeddiiuumm ************
********** 66..22..11 TToo ccrreeaattee aa mmeeddiiuumm ddeeffiinniittiioonn **********
To create a new medium definition, choose the option NEW LOCAL MEDIUM
DEFINITION in the menu ARCHITECTURE of the principal window, this will open a
window for text edition in order to input a name to this new medium definition.
This will open a definition window in which you may modify the type of the
medium (SAM Point to Point, SAM Multipoint, RAM) and the communication
durations list of the medium.

In the durations list window, you specify the type name and its duration, which
is an integer, separated by a ``='' (e.g. ``int = 1''); one duration per line.
Each line specifies the duration required to transfer one element of this type
(e.g. an array of four integers will take 4*1). Notice that if the duration for
one type ``type'' has already been specified in an included library ``lib'' the
duration will appear in the duration window as ``lib/type = ...''. You can
still redefine the duration for your application by adding a line ``type=...''.
This addition will not modify the library itself (no repercusion on other
applications including this library).
********** 66..22..22 TToo mmooddiiffyy aa mmeeddiiuumm ddeeffiinniittiioonn **********
To modify an existing local or global library medium definition, choose the
option EDIT MEDIUM DEFINITION in the menu ARCHITECTURE of the principal window,
this will open a definition window.

********** 66..22..33 TToo ddeelleettee aa mmeeddiiuumm ddeeffiinniittiioonn **********
To delete a local medium definition choose the option DELETE LOCAL MEDIUM in
the menu ARCHITECTURE of the principal window.
************ 66..33 AArrcchhiitteeccttuurree ************
********** 66..33..11 TToo ccrreeaattee aann aarrcchhiitteeccttuurree ddeeffiinniittiioonn **********
To create a new local architecture choose the option NEW LOCAL ARCHITECTURE in
the menu ARCHITECTURE of the principal window, this will open a window for text
edition in order to input a name to this new architecture, and create a new
window labeled "architectureName". Now you may construct a graph with
references to already defined operators and media all together connected. A
reference to an operator or to a medium may belong locally to an application or
belong to a library global to all the applications.

To connect an operator and a medium, or a medium to an operator, point the
cursor at a gate of the operator (respectively the medium) and click the middle
button of the mouse (or CTRL+click the left button of the mouse) and drag to
the gate of the medium (a gate of the operator). When the button is released
the edge will be drawn.

WARNING : it is not allowed to connect together two media, or two operators.
********** 66..33..22 TToo mmooddiiffyy aann aarrcchhiitteeccttuurree ddeeffiinniittiioonn **********
To modify an existing local or global library architecture, choose the option
EDIT ARCHITECTURE in the menu ARCHITECTURE of the principal window, this will
open a window definition.
********** 66..33..33 TToo ddeelleettee aann aarrcchhiitteeccttuurree ddeeffiinniittiioonn **********
To delete a local architecture definition choose the option DELETE LOCAL
ARCHITECTURE in the menu ARCHITECTURE of the principal window.

77.. CChhaarraacctteerriissttiiccss
The heuristics performed by the adequation use the characteristics of each
algorithm definition and each relation (edge) between algorithm definition,
relatively to the operators and the media it may be distributed to. Presently
we are mainly interested in real-time performances then the vertices and the
edges of the algorithm graph must be characterized in terms of duration
relatively to the vertex types of the architecture graph.

Communication characterizations are explained in section ``Medium''. Notice
that the command MAIN DEFINITION PORT TYPES LIST in the ALGORITHM menu gives
you a list of all port types used in your main definition algorithm and its
subhierarchy, which may simplify the specification of communication
characterizations.

To perform definitions characterization, you have two possibilities: - choose
the option DURATIONS in the EDIT menu of an algorithm window (this will open a
dialog window in order to input the characteristics), - edit the definition of
the operator and use the button MODIFY DURATIONS (this will open a dialog
window in order to input the characteristics).

WARNING : You must characterize all vertices of the transformed graph (see
below).
************ 88.. CCoonnssttrraaiinnttss ************
Some vertices of the algorithm graph may be constrained to be executed on a
specific operator, in this case the heuristics will not have the choice in
distributing them. These constraints are specified through "Software
Components". A software component groups operations, all operations of a
software component will be distributed on the same operator.

To create a new software component, choose CREATE SOFTWARE COMPONENT in the
menu EDIT. To attach a reference to a software component, use the option ATTACH
REFERENCE TO SOFTWARE COMPONENT of the contextual menu. If this reference
references a hierarchical definition, the software component will be herited by
all the references of this hierarchy (except if some references of this
hierarchy are themselves attached to another software component). In
particular, if you use this command on a reference to a conditioned definition
(resp. repeated) the software component will be herited by the CondI/CondO
(resp. Explode, Implode) created by SynDEx when flattening the algorithm graph.
You may also attach a specific software component to CondI/CondO/Explode/
Implode by using the options ATTACH CONDI/CONDO/EXPLODE/IMPLODE TO SOFTWARE
COMPONENT. The option ATTACH ALL TO SOFTWARE COMPONENT attaches the same
software component to all these operations. Be aware that this last command is
more prioritary than the others. Therefore, if you specify a software component
to ALL and a different to only CONDI, the software component specified for
CONDI will be ignored.

To constraint the references attached to a given software component to be
distributed on a specific operator, choose CONSTRAINTS in the menu of the
principal window. Then you may impose ABSOLUTE constraints by choosing the
corresponding option. This will open a dialog window in order to input the
constraints.

To create an absolute constraint in the constraints window, click on an
operator in the left list, then click on an operator in the middle and finally
click on the CREATE button. This will add the new constraint in the right list.


To delete an absolute constraint, click on a constraint in the right list, then
click on the REMOVE button or directly double-click on the constraint. Click on
the OK button to confirm your new constraint list, otherwise click on the
CANCEL button.
************ 99.. AAddeeqquuaattiioonn ************
You may have constructed several local algorithm and/or architecture
definitions, but only one of them may be labeled "(main)" becoming the
algorithm (main) which will be mapped onto the architecture (main), when the
adequation is performed.

To label an algorithm window or an architecture window with "(main)", choose
MAIN DEFINITION (for the algorithm) or MAIN ARCHITECTURE (for an architecture)
in the EDIT menu.

To run the adequation, i.e. the optimization heuristics provided by SynDEx,
choose between NO FLATTEN or FLATTEN. In both cases, the main algorithm graph
is transformed by SynDEx to obtain a graph with a unique level of hierarchy,
where each vertex is an operation in the sense of AAA (which is the same as an
atomic definition in SynDEx). This transformation consists in replacing
references, by corresponding definitions, and replacing paths of dependences
connected along the hierarchy through ports, by direct dependences between
corresponding ports of the transformed operations. The difference between NO
FLATTEN and FLATTEN lies in the references resolution.

With NO FLATTEN, explicit hierarchy is ignored. In the graph of the main
definition all references are directly replaced by operations containing the
same ports as their definition. References or dependences included in those
definitions are ignored. Additionnally, repetitions are expanded.

With FLATTEN, references corresponding to explicitly hierarchical definitions
are replaced by the graph of this definition, conditioning and repetitions are
expanded. This process is iterated until all vertices of the transformed graph
become atomic (no hierarchy remains).

Notice that SynDEx needs characterization for each vertex of the transformed
graph to perform the adequation. If you chose NO FLATTEN, do not forget to
characterize the definitions corresponding to references at the highest level
of hierarchy in the main algorithm. With FLATTEN you only need to characterize
atomic definitions. You will also have to characterize additional operations
generated by SynDEx when you use conditioning or repetition.

Once the adequation has been computed, or loaded from a previously saved
adequation result, the VIEW SCHEDULE command of the ADEQUATION MENU opens a
window showing a view of the shedules and distribution produced by the
adequation. This window gives a diagram of the real-time simulation of the
algorithm executed on the architecture.

The adequation result is appended to your sdx file once the adequation has been
performed and you save your application.

In the timing window you will find one timing, describing a distribution, for
each operator and each medium of the architecture. Each timing for an operator
describes a scheduling of constants (by default not displayed, option SHOW
CONSTANTS in WINDOW/OPTION), sensors, actuators, memories and operations. Each
timing for a medium describes a scheduling of inter-operator communications,
sending or receiving data from or to an operator. Each box has a length which
is proportional to the duration of the corresponding operation. When you have
important duration differences between definitions, you can disable this
proportionnal display, each box will have the same length (option SCALE in
WINDOW/OPTION).

When the cursor points at a box this one is highlighted (yellow) as well as the
boxes it is in relation of execution precedence, i.e. its predecessors (red)
and successors (green). You may ask for drawing arrows between boxes which are
in relation of execution precedence by choosing the option ARROWS in the window
obtained from the WINDOW/OPTIONS menu; you may also choose to have the time in
horizontal (horizontal view) or in vertical (vertical view). You may move a
timing line or column in order to rearrange their respective positions: point
the cursor at this line or column, click the left button of the mouse and drag
until the new position.
************ 1100.. CCooddee ggeenneerraattiioonn ************
When the Adequation has been performed, code may be generated for the (main)
architecture. Choose the GENERATE CODE option of the menu CODE. This will
generate for each operator of the architecture the code in a file
"operator.m4". The files generated are located in the directory of the current
SynDEx application. The files generated may be viewed choosing the option VIEW
CODE of the menu CODE.

WARNING: to generate code, it is mandatory that an operator of the architecture
have been labeled "main" (using the contextual menu).
************ 1100..11 OOvveerrvviieeww ************
In this section we give a brief summary of files you will require to generate
and compile your executive. Code generation principles will be detailed in next
sections. Files required are :
    * One ``processorName.m4'' file for each processor specified in your main
      architecture, including ``root.m4''. These files are generated during the
      executive generation by SynDEx;
    * ``applicationName.m4m'';
    * ``applicationName.m4x'', which may be empty;
    * ``GNUmakefile'';
    * ``root.m4x''.
For the files which are not generated by SynDEx, most of the time you can
simply copy existing ones (for instance from the example directory) and make
modifications explained in the comments of these files.

Once you gathered all these files, type ``make'' in your shell. This will
compile, download and execute one executive for each processor.

You can also clean your directory by typing ``make clean''.
************ 1100..22 HHooww ttoo CCoommppiillee aann EExxeeccuuttiivvee ************
Each macro-executive source file must be first translated by the GNU m4
macroprocessor, into a text file in the language preferred for the processor
(usually assembler for efficiency, sometimes C or another high-level language
for portability). This translation relies on several files included in the
following order:
    * the first macro-call of the macro-executive source: "include
      (syndex.m4x)", includes the file syndex.m4x, which defines all the SynDEx
      generic (processor-independent) macros, which rely on low-level specific
      macros expected to be defined by the following included files;
    * the second macro-call of the macro-executive source: "processor_
      (processorType, processorName, applicationName, version, date)" (where
      "processorType", "processorName", and "applicationName" respectively
      stand for the processor type name, the processor name, and the
      application name, as specified under SynDEx), includes:
          o the file processorType.m4x, which defines low-level macros specific
            to the processorType,
          o the file applicationName.m4x, which defines application-specific
            macros,
          o the file processorName.m4x, if it exists, which defines macros
            specific to processorName only.
    * then, after the memory-allocation macro-calls, each communication
      sequence starts with a "thread_(mediaType, mediaName, processorNames)"
      macro-call (where "mediaType", "mediaName", and "processorNames"
      repectively stand for the medium type name, the medi name, and the list
      of the names of the processors connected to the medium, as specified
      under SynDEx), which includes the file mediaType.m4x, which defines low-
      level communication macros specific to the medium type.
These indirected inclusions, through the names specified under SynDEx, provide
a very flexible and powerful mechanism needed to support efficiently
heterogeneous architectures, with heterogeneous languages and compilation
chains.

Then each macroprocessed text file must be compiled with the adequate compiler,
and linked with the adequate linker against separately compatibly-compiled
application-specific files and/or processor-specific libraries, for those
macros which cannot simply inline the desired code, but instead must call
separately compiled codes.
************ 1100..33 HHooww ttoo LLooaadd tthhee CCoommppiilleedd EExxeeccuuttiivvee ************
In an heterogeneous architecture, there are different compilation chains, with
different executable formats, which have to be transfered through different
types of intermediate media and processors, to be finally loaded by different
boot loaders. For these reasons, a postprocessor is required for each type of
operator, in order to encapsulate this heterogeneity into a common download
format. This is explained in more details in the Downloader Specification (cf.
chapter _1_1).
************ 1100..44 HHooww ttoo AAuuttoommaattee tthhee CCoommppiillaattiioonn//LLooaadd PPrroocceessss ************
All processor types require the same compilation sequence, but with different
compilation tools:
    * macroprocessing of the macro-executive generated by SynDEx,
    * compilation into processor-specific object code,
    * linking into processor-memory-map-specific executable code,
    * postprocessing into common downloadable format.
This compilation sequence may be automatically generated for each processor by
macroprocessing the macro-makefile generated by SynDEx, which includes:
    * a very first macro-call: "include(syndex.m4m)" includes the file
      syndex.m4m, which generates a makefile header, and defines the macros
      "architecture_", "processor_", "connect_", and "endarchitecture_" used in
      the macro-makefile;
    * the second macro-call: "architecture_(applicationName, version, date)"
      (where "applicationName" stands for the application name, as specified
      under SynDEx), includes the file applicationName.m4m, if it exists, which
      defines application-specific make-macros;
    * for each processor, a macro-call: "processor_(processorType,
      processorName, connectorsTypeAndName)" (where "processorType",
      "processorName", and "connectorsTypeAndName" respectively stand for the
      processor type name, the processor name, and a list of pairs, one for
      each media-connector of the processor, with the medium type name and the
      media-connector name, as specified under SynDEx), includes the file
      processorType.m4m, which should have for side effect to generate the
      required compilation dependences for this processor;
    * for each medium, a macro-call: "connect_(mediaType, mediaName,
      connectorsOprAndName)" (where "mediaType", "mediaName", and
      "connectorsOprAndName" respectively stand for the medium type name, the
      medium name, and a list of pairs, one for each processor connected to the
      medium, with the processor name and its media-connector name, as
      specified under SynDEx), includes the file mediaType.m4m, if it exists,
      which should have for side effect to generate any loader-specific
      dependences (presently unused).
Although this indirect inclusion mechanism is able to generate most of the core
makefile, an application-specific "top" makefile is still required to specify
how to generate the core makefile, and to specify the compilation and linking
dependencies with application-specific files (include files, separately
compiled files and libraries).

1111.. SSyynnDDEExx DDoowwnnllooaaddeerr SSppeecciiffiiccaattiioonn
************ 1111..11 CCoonntteexxtt ************
SynDEx allows the efficient programming of parallel, distributed, heterogeneous
architectures, composed of several different types of processors, and of
several different types of communication medium. From a user specification of
an algorithm dataflow graph and of an architecture resources graph, and from
algorithm and architecture characterized libraries, SynDEx automatically
generates an application specific executive code for each processor, and a
makefile to automate the compilation and linking of each executive, and its
downloading into the program memory of the corresponding processor.

Separate programming of non-volatile program memories being unpractical, SynDEx
considers that each processor has, for only non-volatile resident program, a
boot-loader (which may be very small and simple, or may rely on a big and
complex operating system) expecting an executive to be downloaded from a
neighbour processor through a communication medium, except for a single "host"
processor, designated by the name "root" in the specified architecture graph,
which boot-loader expects all executives to be stored altogether in its local
non-volatile memory.

Consequently, SynDEx computes, over the architecture graph, an oriented
coverage tree rooted on the "root" processor, and generates in each processor
executive the code needed to download the compiled executives through this
tree, in a predetermined order which is also used to generate the makefile.
************ 1111..22 BBoooott aanndd DDoowwnnllooaadd PPrroocceessss ************
This process is the same for all processors, except that the root processor
gets executives from its local non-volatile memory, whereas all the other
processors get executives from their neighbour processor which is their
ascendant towards the root of the download tree. The processors which have the
same ascendant processor are called the descendants of that processor.

When powered on, each processor boots by executing its resident boot-loader,
which gets the processor's executive, loads it into the processor's program
memory, and executes it. During its initialization phase, the executive gets
and forwards executives to all its descendants, before proceeding with
application data processing.

The root processor, usually an embedded PC or other kind of workstation,
bootloads from its disk an operating system, which automatically loads and
executes a startup program allowing the user to choose between different
applications. During early developments, this program may be a simple shell
(but this requires a keyboard to be available), and the user enters a "make"
command to compile the executives if needed, and to execute the root executive,
with the other executive files passed as arguments on the command line. In
applications where it is unpractical to use a keyboard permanently connected,
the startup program may use another input device (for example a switch or a
touch screen) to let the user choose between different predefined shell
commands, starting different applications through the corresponding "make"
command, or simply launching a shell for interaction with a keyboard. In more
deeply embedded applications, where the root processor has neither a disk nor
an operating system, all the executives are stored in a FLASH memory, and the
root processor boots by executing directly its own executive, and finds the
other executives sequentially stored in its FLASH.

The first executive forwarded to a descendant is received, stored, and executed
by that descendant's boot-loader. Then, while that descendant's executive asks
for executives, the ascendant executive gets and forwards the next executives
to the same descendant, until that descendant's executive signals that it has
itself no more executives to forward. Then the ascendant may switch to its next
descendant, until it has no more descendant to service, and hence no more
executive to forward. This fully sequential download process boots processors
in the order of a depth-first traversal of the download tree.

In the case of a point-to-point medium, the descendant executive may proceed to
application data communications as soon as it has no more executive to forward,
whereas in the case of a multipoint medium, the descendant executive must wait
until the ascendant executive signals that it has no more executive to forward
(to avoid communication interferences between descendant application data and
ascendant download data).
************ 1111..33 CCoommmmoonn DDoowwnnllooaadd FFoorrmmaatt ************
Each processor type may have a different compiler (linker) output format, and
some processor types may have a ROM-ed embedded boot-loader (firmware), with
its own requirements on the download format. The SynDEx common download format
encapsulates the details and the differences of the compiler output formats,
and of the boot-loaders download formats; it is composed as follows:
    * four bytes prefix encoding the 32 bits big-endian total length of the
      following sequence of bytes
    * sequence of bytes, encoding one complete executive, structured as
      required by the destination boot-loader, and padded if needed with null
      bytes until the total length is a multiple of four.
The first executive forwarded to a descendant being received by that
descendant's boot-loader, that executive must be sent WITHOUT its four bytes
prefix; the following executives sent to the same descendant being forwarded by
that descendant's executive, they must be sent WITH their four bytes prefix.

The sequence of bytes itself must follow the format expected by the destination
boot-loader. Therefore a linker post-processor must be developped for each
processor type, to translate the linker output file into the SynDEx common
dowload format described above. All the post-processors' outputs will be
concatenated by the makefile into a unique contiguous image (file), that the
root executive will use as source.
************ 1111..44 DDoowwnnllooaaddeerr MMaaccrrooss ************
The downloader code is generated by two macros:
    * "loadFrom_" starts the initialization phase of the communication sequence
      of the medium connected to the ascendant processor; its first argument is
      the name of the ascendant processor, its next arguments, if any, are the
      names of the other medium connected to descendant processors, if any;
    * "loadDnto_" starts the initialization phase of the communication sequence
      of each medium connected to a descendant processor; its first argument is
      the name of the medium connected to the ascendant processor, its next
      argument(s) is (are) the name(s) of the descendant processor(s).
Processor names are usefull to address processors connected to multipoint
medium: a processor name may be suffixed to give the name of a user defined
macro, which substitution gives the processor address.

As executives data may be forwarded through several communication medium of
different bandwidths, transfers must be synchronized such that data flow at the
speed of the slowest medium.

Between processors, if flow control is not supported by the medium hardware, it
must be implemented by "ready to receive" control messages sent by the
loadFrom_ code for each chunk of data to be sent by the loadDnto_ code. Inside
a processor, the loadFrom_ and loadDnto_ macros cooperation is based on the
order in which the spawn_thread_ macros (one for each communication sequence,
i.e. for each communication media) are generated in the initialization phase of
the "main_ ... endmain_" sequence: the spawn_thread_ macro corresponding to the
thread_ macro of the communication sequence starting with the loadFrom_ macro
(i.e. of the media connected to the ascendant processor) is called first,
followed by the other spawn_thread_ macros, among which the ones, if any,
corresponding to the communication sequences with a loadDnto_ macro (i.e. of
the media connected to the descendant processors).

If the processor is a leaf node of the download tree, its loadFrom_ macro has
only one argument; in this case, it directly generates the code sending to the
ascendant processor a "null" message meaning that no more executive is
requested, followed, in the case of a multipoint medium, by the code waiting
for other executives to be downloaded to the other processors connected to the
medium, until the ascendant processor sends an "empty" executive meaning that
the download process is complete on this medium.

Otherwise, before generating the code described in the previous paragraph, the
loadFrom_ macro generates a RETURN instruction (which will return control after
the CALL instruction generated by the spawn_thread_ macro), followed by a
"loadFrom_end_:" label, and the loadFrom_ macro also defines three macros for
use by the loadDnto_ macros:
    * the "loadFrom_req_" macro must generate the code that sends a "non-null"
      message requesting the ascendant processor to download another executive;
    * the "loadFrom_get_" macro must generate the code that receives one "word"
      of executive data from the ascendant processor; "word" means the size of
      a processor register, usually 32 bits; if the communication medium
      transfers executive data by chunks of N words, then every N calls to the
      code generated by the loadFrom_get_ macro receives a full chunk of data
      and returns its first word, and the next N-1 calls each return a next
      word of the chunk;
    * the "loadFrom_next_" macro, which is called at the end of each loadDnto_
      macro, must generate a "CALL loadFrom_end_", but only for the very last
      loadDnto_ macro.
If the code generated by any of these three macros is limited to a few
instructions, it may be generated inline, otherwise the loadFrom_ macro
generates this code as a subroutine (between the RETURN instruction and the
loadFrom_end_: label), and a call to that subroutine is generated instead of
the inline code.
************ 1122.. LLiinnkkss ************
_S_y_n_D_E_x_ _:_ _h_t_t_p_:_/_/_w_w_w_-_r_o_c_q_._i_n_r_i_a_._f_r_/_s_y_n_d_e_x

_O_b_j_e_c_t_i_v_e_ _C_a_m_l_ _:_ _h_t_t_p_:_/_/_c_a_m_l_._i_n_r_i_a_._f_r_/_i_n_d_e_x_-_e_n_g_._h_t_m_l
_T_c_l_/_T_k_ _:_ _h_t_t_p_:_/_/_w_w_w_._s_c_r_i_p_t_i_c_s_._c_o_m_/
_C_a_m_l_T_k_ _:_ _h_t_t_p_:_/_/_p_a_u_i_l_l_a_c_._i_n_r_i_a_._f_r_/_c_a_m_l_t_k_/
_A_A_A_ _m_e_t_h_o_d_o_l_o_g_y_ _(_S_y_n_D_E_x_ _f_u_n_d_a_m_e_n_t_a_l_s_)_ _:_ _h_t_t_p_:_/_/_w_w_w_-_r_o_c_q_._i_n_r_i_a_._f_r_/_s_y_n_d_e_x_/_p_u_b_/
_e_x_e_c_v_4_/_e_x_e_c_v_4_._p_d_f

===============================================================================
     Julien Forget 2003-11-28
